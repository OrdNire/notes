# 目录

[TOC]

# 算法基础



## 0x0 基础算法

### 排序



#### 快速排序

> 快速排序是一种排序算法，通过选定一个基准点，将序列中小于基准点和大于基准点的数放置基准点的左右两侧，再递归左右两侧达到排序

快排的时间复杂度：$$O(NlogN)$$

算法基本思路（以结果正序为例）：

- 选定一个基准点
- 将序列中小于基准点的数放入基准点的左边，大于基准点的数放入基准点的右边
- 递归处理左右两边

典型例题：

[快排](https://www.acwing.com/activity/content/problem/content/819/1/)

[快速选择](https://www.acwing.com/problem/content/788/)

**代码模板**

```c
void quick_sort(int q[], int l, int r)
{
    if (l >= r) return;

    int i = l - 1, j = r + 1, x = q[l + r >> 1];
    while (i < j)
    {
        do i ++ ; while (q[i] < x);		
        do j -- ; while (q[j] > x);		
        if (i < j) swap(q[i], q[j]);	// 交换使得小于基准点的数在左边，大于基准点的数在右边
    }
    quick_sort(q, l, j), quick_sort(q, j + 1, r);	// 递归左右两侧
}
```

**为什么需要先i ++、j -- 后再判断？**

因为假设出现 `4 4 4 ` 这种情况，如果先判断再指针移动，那么可能会出现 `i` 指向第一个 4，`j` 指向最后一个 4，都不满足条件，那么此时两个位置都交换，交换后仍然是 `4 4 4`，陷入死循环



#### *归并排序

> 归并排序是利用的递归回溯的过程进行排序，核心是回溯时，回溯的上一层已经使得两个子序列有序，只需要将两个有序子序列排序为有序，再回溯的下一层

归并的时间复杂度：$$O(NlogN)$$

算法基本思路（以结果正序为例）：

- 取序列中点
- 递归左边和右边
- 将左边和右边排序为一个有序序列

**代码模板**

```c
void merge_sort(int q[], int l, int r)
{
    if (l >= r) return;

    int mid = l + r >> 1;
    merge_sort(q, l, mid);
    merge_sort(q, mid + 1, r);

    int k = 0, i = l, j = mid + 1;
    while (i <= mid && j <= r)
        if (q[i] <= q[j]) tmp[k ++ ] = q[i ++ ];
        else tmp[k ++ ] = q[j ++ ];

    while (i <= mid) tmp[k ++ ] = q[i ++ ];
    while (j <= r) tmp[k ++ ] = q[j ++ ];

    for (i = l, j = 0; i <= r; i ++, j ++ ) q[i] = tmp[j];
}
```



### *二分

> 二分的思想在于可以将区间分为两半，一半是不满足条件的可以直接丢弃，再递归处理满足条件的另一半

时间复杂度：$$O(logN)$$



#### 整数二分

> 整数二分有两种模板，运用哪种模板需要看对应的check函数是左半边满足条件为真还是右半边满足条件为真

**代码模板**

```c
bool check(int x) {/* ... */} // 检查x是否满足某种性质

// 区间[l, r]被划分成[l, mid]和[mid + 1, r]时使用：
int bsearch_1(int l, int r)
{
    while (l < r)
    {
        int mid = l + r >> 1;
        if (check(mid)) r = mid;    // check()判断mid是否满足性质
        else l = mid + 1;
    }
    return l;
}
// 区间[l, r]被划分成[l, mid - 1]和[mid, r]时使用：
int bsearch_2(int l, int r)
{
    while (l < r)
    {
        int mid = l + r + 1 >> 1;
        if (check(mid)) l = mid;
        else r = mid - 1;
    }
    return l;
}
```

对于两个模板如何使用，可参考一个例子： [数的范围](https://www.acwing.com/activity/content/problem/content/823/1/)

> 该例子是要求对于一个有序的序列，求某个数的范围

而求范围需要知道该数的起始点和终止点，那么我们可以用整数二分的两个模板分别求出范围

![二分0](https://cdn.jsdelivr.net/gh/OrdNire/notes/img/202112101433858.png)

假设我们需要求出3的范围，那么我们先求出起始点。求出起始点可以是`check`函数在红色框范围内满足条件，`check() q[mid] >= x`

这样如果中心点在红色框内，那么`check`必定满足条件，正确答案一定在左半边，利用`bsearch_1`模板，可以一直求出红色框的左边界，也就是`x == 3`的起始点

同理，如果我们要找`x == 3`的终止点，可以利用`check`满足左边，利用`bsearch_2`模板即可找到绿色框的右边界，即`x == 3`的终止点



####  浮点数二分

> 浮点数二分相对来说比较容易，例如求x^3的根，那么其实我们可以二分一个范围，然后是否满足x^3等于结果，求出x

[浮点数二分](https://www.acwing.com/problem/content/792/)

**代码模板**

```c 
bool check(double x) {/* ... */}	// 满足某种性质

double bsearch_3(double l, double r)
{
    const double eps = 1e-6;		// eps 表示精度，取决于题目对精度的要求
    while(r - l > eps)
    {
        double mid = (l + r) / 2;
        if(check(mid)) r = mid;
        else l = mid;
    }
    return l;
}
```



### 高精度

> 高精度就是当数的位数很大时，我们可以利用数组来模拟数的加减乘除
>
> 利用数组来模拟高精度时，我们采用逆序的方式存储，因为我们在算加减乘除时都是以最低位开始一位位算



#### 高精度加法

**代码模板**

```c 
// C = A + B, A >= 0, B >= 0
vector<int> add(vector<int> &A, vector<int> &B) {
    vector<int> C;
    for(int i = 0, t = 0;i < A.size() || i < B.size();i ++) {
        if(i < A.size()) t += A[i];
        if(i < B.size()) t += B[i];
        C.push_back(t % 10);
        t /= 10;
    }
    
    if(t) C.push_back(t);
    return C;
}
```

#### 高精度减法

**代码模板**

```c
// C = A + B, 满足 A >= B,A >= 0,B >= 0
vector<int> sub(vector<int> &A, vector<int> &B) {
    vector<int> C;
    for(int i = 0, t = 0;i < A.size();i ++) {
        t = A[i] - t;
        if(i < B.size()) t -= B[i];
        C.push_back((t + 10) % 10);
        if(t < 0) t = 1;
        else t = 0;
    }
    
    while(C.size() > 1 && C.back() == 0) C.pop_back();		// 去除前导零
    return C;
}
```



#### 高精度乘法(高精度乘以低精度)

**代码模板**

```c
// C = A * b, A >= 0, b > 0
vector<int> mul(vector<int> &A,int b) {
    vector<int> C;
    for(int i = 0,t = 0;i < A.size();i ++) {
        if(i < A.size()) t += A[i] * b;
        C.push_back(t % 10);
        t /= 10;
    }
    
    while(C.size() > 1 && C.back() == 0) C.pop_back();
    return C;
}
```



#### 高精度除法(高精度除以低精度)

**代码模板**

```c
// C = A / b .... r, A >= 0, b > 0
vector<int> div(vector<int> A, int b, int &r) {
    vector<int> C;
    for(int i = A.size() - 1;i >= 0;i --) {
        t = t * 10 + A[i];
        C.push_back(t / b);
        t %= b;
    }
    
    reverse(C.begin(),C.end());
    while(C.size() > 1 && C.back() == 0) C.pop_back();
    return C;
}
```



### *前缀和与差分

#### 一维前缀和

> 一维前缀和：计算序列中从`1 ~ i(1 <= i <= n)`的和，那么`i ~ j`区间的和可以利用`S[i] - S[j - 1]`求出
>
> 前缀和是将求序列某区间的和的时间复杂度降为 O(1)

时间复杂度$$O(n)$$

**代码模板**

```c
S[i] = a[1] + a[2] + ... + a[i];
a[l] + .... + a[r] = S[r] - S[l - 1]
```



**二维前缀和**

>二维前缀和是以O(1)的复杂度求一个矩阵中，某一块中数的和

![前缀和](https://cdn.jsdelivr.net/gh/OrdNire/notes/img/202112101433427.png)

**代码模板**

```c
S[i, j] = 第i行j列格子左上部分所有元素的和
以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵的和为：
S[x2, y2] - S[x1 - 1, y2] - S[x2, y1 - 1] + S[x1 - 1, y1 - 1]
```



#### 一维差分

> 差分是以O(1)的时间复杂度求某一个区间中每个数加上某一个值

算法基本思路：

对于差分数组，我们可以先假设我们要求的数组是一个前缀和的数组，那么我们操作可以对前缀和的差分数组进行操作

假设有`b`为差分数组，求`l ~ r`区间内所有的点加上`c`，那么我们可以`b[l] += c, b[r + 1] -= c`，实现的效果就是我们在对差分数组求前缀和时，`l`点开始就加上了`c`，那么后面的所有数都加上了`c`，之后在`r + 1`的位置减去`c`，那么其后面就不会加`c`

**代码模板**

```c
给区间[l,r]中每个数加上c：B[l] += c, B[r + 1] -= c;
```



**二维差分**

> 二维差分其实可以类比一维差分和二维前缀和

算法基本思路：

二维差分如果求`(x1,y1)和(x2,y2)`之间的每个数加上`c`，那么我们在`(x1,y1) `加上`c`，效果就是以`(x1,y1)`右下角的所有值都加上了`c`，所以我们可以减去除我们要的区间外所有的值一个`c`

**代码模板**

```c
以(x1,y1)为左上角，(x2,y2)为右上角的区间内加上一个c
S[x1,y1] += c, S[x2 + 1, y1] -= c, S[x1, y2 + 1] -= c, S[x2 + 1, y2 + 1] += c;
```



### *双指针

> 双指针的作用是对于有规律或者单调性的序列，可以利用双指针优化算法

[acwing.最长连续不重复子序列](https://www.acwing.com/problem/content/801/)

常见问题分类：

- 对于一个序列，用两个指针维护一段区间
- 对于两个序列，维护某种次序，比如归并排序中合并两个有序序列的操作

**代码模板**

```c
for(int i = 0,j = 0;i < n;i ++) {
	
    while(j < i && check(i,j)) j ++;
    
    // 具体逻辑

}
```



### 位运算

> 位运算常用的就是lowbit函数

`lowbit`函数的作用是返回`n`中最后一位`1`

**lowbit**

```c
int lowbit(int n) {
    return n & -n;
}
```



### 离散化

> 所谓离散化，就是对于区间特别大， 数特别散的序列，如果直接存将浪费很多不必要的空间，离散化就是将每次的操作使用到的下标存储到一个数组中，再利用二分查找下标对应的离散化后数组中的下标

[acwing.区间和](https://www.acwing.com/problem/content/804/)

**代码模板**

```c
vector<int> alls; // 存储所有待离散化的值
sort(alls.begin(), alls.end()); // 将所有值排序
alls.erase(unique(alls.begin(), alls.end()), alls.end());   // 去掉重复元素

// 二分求出x对应的离散化的值
int find(int x) // 找到第一个大于等于x的位置
{
    int l = 0, r = alls.size() - 1;
    while (l < r)
    {
        int mid = l + r >> 1;
        if (alls[mid] >= x) r = mid;
        else l = mid + 1;
    }
    return r + 1; // 映射到1, 2, ...n
}
```



### 区间合并

> 区间合并的题其实类似于贪心，合并区间我们只需要根据左端点排序，然后将区间有覆盖的合并成一个区间即可

[acwing.区间合并](https://www.acwing.com/problem/content/805/)

**代码模板**

```c
// 将所有存在交集的区间合并
void merge(vector<PII> &segs)
{
    vector<PII> res;

    sort(segs.begin(), segs.end());

    int st = -2e9, ed = -2e9;
    for (auto seg : segs)
        if (ed < seg.first)
        {
            if (st != -2e9) res.push_back({st, ed});
            st = seg.first, ed = seg.second;
        }
        else ed = max(ed, seg.second);

    if (st != -2e9) res.push_back({st, ed});

    segs = res;
}
```



## 0x1 数据结构



### 链表

> 在算法中通常使用数组来模拟链表，即静态链表。原因在于我们不需要每次都创建一个新的结构体或新的对象，减小时间开销



#### ***单链表**

> 用数组模拟，需要一个指向链表的头指针，这里的头用一个整型表示其所在的索引即可

**代码模板**

```c
int head, e[N], ne[N], idx;	// head 表示头，e表示存储的实际值，ne表示指向下一个的指针，idx 表示数组中可用的空间

head = -1;			// 需要预先初始化head

// 采用头插法
void add(int x) {
    e[idx] = x;
    ne[idx] = head;
    head = idx ++;
}
```

#### **双链表**

> 双链表就是将ne变为分别指向左边和右边的数



### 栈

> 栈是一种后进先出的数据结构

**模拟栈**

```c
int stk[N], tt = 0;	// tt 表示栈顶

stk[++ tt] = x;	// 入栈

tt --;		// 出栈

stk[tt];	// 取出栈顶
    
tt <= 0		// 表示栈空
```

`c++`中的`stl`有`stack<T>`可表示栈



### **单调栈 **

[acwing.单调栈](https://www.acwing.com/problem/content/832/)

> 单调栈是根据具有单调性的题目，维护一个单调性的栈
>
> 最典型的例子就是求每一个数左边第一个比它小的值，那么我们只需要维护一个单调递增的栈，栈顶就是左边第一个比它小的值

**代码模板**

```c
//常见模型：找出每个数左边离它最近的比它大/小的数
int tt = 0;
for (int i = 1; i <= n; i ++ )
{
    while (tt && check(stk[tt], i)) tt -- ;
    stk[ ++ tt] = i;
}
```





### 队列

> 队列是一种先进先出的数据结构，类似于排队

**模拟队列**

```c
int q[N], hh = 0, tt = -1;

q[++ tt] = x;	// 入队

hh ++;	// 出队

q[hh];	// 队头

if(hh > tt) // 表示队空
```



**单调队列**

> 单调队列和单调栈的思想也是维护一个单调的区间，用于优化算法

[acwing.滑动窗口](https://www.acwing.com/problem/content/156/)

最典型的模板就是滑动窗口的题

滑动窗口中求窗口内的最小值，可以知道，如果滑动窗口中新进的值的左边的数如果比它大，那么它一定不会是答案，因为它是比新进的值先出且大于该值，所以其一定不是答案，根据这个特点，我们可以维护一个单调递减的队列，来维护一个区间的最小值

**代码模板**

```c
//常见模型：找出滑动窗口中的最大值/最小值
int hh = 0, tt = -1;
for (int i = 0; i < n; i ++ )
{
    while (hh <= tt && check_out(q[hh])) hh ++ ;  // 判断队头是否滑出窗口
    while (hh <= tt && check(q[tt], i)) tt -- ;
    q[ ++ tt] = i;
}
```



### ^KMP

kmp是优化字符串的匹配算法

暴力做法：如果我们采用暴力的做法，如果在某一点没匹配成功，那么我们需要重新从模式串$(p)$ 的起始位置和原串$(s)$ 后一个继续匹配，那么这就会存在一个回退的过程。

kmp：可以发现，在某一点匹配后，前面的一段是已经匹配成功的，那么如果前面的一段中存在**某一段前缀和后缀相等，那么我们可以直接将模式串定位到前缀的末尾，开始匹配，那么这样就省去了一个回退的过程**

参考：[kmp匹配过程](https://leetcode-cn.com/problems/shortest-palindrome/solution/tu-jie-kmpsuan-fa-by-yangbingjie/)

**kmp中next数组的含义**：综上，我们需要存下来以每一个点 $i$ 结尾的后缀和前缀相等的最大长度，那么 $next[i] = j$ 中 $j$ 就表示前缀和后缀相等的长度，那么重新定位的时候就可以直接从 $P_j$ 开始

**原串和模式串错开一个：原串 $S_i$ 匹配模式串 $P_{i + 1}$**

**代码模板**

```cpp
// 匹配过程
// 模式串 P 的长度为 n，原串的长度为 m
for(int i = 1,j = 0;i <= m;i ++) {
    if(j && s[i] != p[j + 1]) j = ne[j];
    if(s[i] == p[j + 1]) j ++;	// 匹配成功右移j一位
    if(j == n) {
        // 匹配成功
    }
}
```

**next数组的初始化和匹配过程一致，不过就是匹配前缀和后缀是否相等**

```cpp
// 初始化next
// i 从 2 开始是因为，i 为 1 时，没有前缀和后缀，匹配的长度为 0
for(int i = 2,j = 0;i <= n;i ++) {
	if(j && p[i] != p[j + 1]) j = ne[j];
    if(p[i] == p[j + 1]) j ++;
    ne[i] = j;
}
```



### ^Trie树

> trie树是又称字典树，就是一种快速查找相同单词以及出现次数的数据结构

**思想**

trie树是通过建立以每一个字母为根节点，然后26个字母为分支的树，那么查询的时候就可以直接按照每一个字母，查询是否在以某个字母为根的分支当中，如果存在，那么以该字母为根，递归执行即可。每次我们都可以统计当前路径的数量，即当前路径组成的单词数量

**建立时需要建立一个空节点同时也是根节点**

**代码模板**

```cpp
int son[N][26], cnt[N], idx;
// 0即是空节点也是根节点

void insert(char *str) {
    int p = 0;
    for(int i = 0;str[i];i ++) {
        char u = str[i] - '0';
        if(!son[p][u]) son[p][u] = ++ idx;
        p = son[p][u];
    }
    cnt[p] ++;
}

int query(char *str) {
    int p = 0;
    for(int i = 0;str[i];i ++) {
        int u = str[i] - '0';
        if(!son[p][u]) return 0;
        p = son[p][u];
    }
    return cnt[p];
}
```



### *并查集

> 并查集是快速查询两个点是否在同一个集合中，也可以判断图中节点的所在的子图是否连通

**思想**

并查集的思想是一种优化查询两点是否在同一集合中。**主要思想在于并查集用一个点来代变整个集合，那么我们只需要判断点是否相等来判断是否任意两点是否在同一集合**。

并查集可以采用树的方式进行存储

对于关系对 $(a,b)$ ，我们可以选择 $b$ 作为 $a$ 的父节点，然后递归找到 $b$ 的最后的父节点（找到 b 所在的代表该集合的点），递归找到a的父节点，最后连接两点，并入一个集合

**代码模板**

```cpp
// 1. 朴素并查集
int p[N]; 	// 存储每个点的祖宗节点

// 初始化
for(int i = 1;i <= n;i ++) p[i] = i;	// 初始祖宗节点都是自己

int find(int x) {
    if(p[x] != x) p[x] = find(p[x]);	// 如果祖宗节点不是自己就一直找下去，并进行路径压缩
    return p[x];
}

void merge(int a,int b) {
	p[find(a)] = find(b);
}
```
```cpp
// 2. 维护集合中点的个数 size

int p[N], size[N];	//size[] 只有祖宗节点有意义，表示该点代表的集合中点的个数

// 初始化
for(int i = 1;i <= n;i ++) {
    p[i] = i;
    size[i] = 1;
}

int find(x) {
    if(p[x] != x) p[x] = find(p[x]);
    return p[x];
}

void merge(int a, int b) {
    size[find(b)] += size[find(a)];
    p[find(a)] = find(b);
}

```



### * 线段树

> 线段树是竞赛中常用的数据结构，主要用来维护区间信息，可以实现$O(logn)$的区间修改，以及求区间和，区间乘等多种操作

这里有篇文章简单介绍了 [线段树](https://zhuanlan.zhihu.com/p/106118909#:~:text=%E7%BA%BF%E6%AE%B5%E6%A0%91%20%EF%BC%88Segment%20Tree%EF%BC%89%E5%87%A0%E4%B9%8E%E6%98%AF%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B%E6%9C%80%E5%B8%B8%E7%94%A8%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%BA%86%EF%BC%8C%E5%AE%83%E4%B8%BB%E8%A6%81%E7%94%A8%E4%BA%8E%E7%BB%B4%E6%8A%A4%20%E5%8C%BA%E9%97%B4%E4%BF%A1%E6%81%AF%20%EF%BC%88%E8%A6%81%E6%B1%82%E6%BB%A1%E8%B6%B3%E7%BB%93%E5%90%88%E5%BE%8B%EF%BC%89%E3%80%82,%E4%B8%8E%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84%E7%9B%B8%E6%AF%94%EF%BC%8C%E5%AE%83%E5%8F%AF%E4%BB%A5%E5%AE%9E%E7%8E%B0%20%E7%9A%84%20%E5%8C%BA%E9%97%B4%E4%BF%AE%E6%94%B9%20%EF%BC%8C%E8%BF%98%E5%8F%AF%E4%BB%A5%E5%90%8C%E6%97%B6%E6%94%AF%E6%8C%81%20%E5%A4%9A%E7%A7%8D%E6%93%8D%E4%BD%9C%20%EF%BC%88%E5%8A%A0%E3%80%81%E4%B9%98%EF%BC%89%EF%BC%8C%E6%9B%B4%E5%85%B7%E9%80%9A%E7%94%A8%E6%80%A7%E3%80%82)

**思想**

线段树其实就是利用数的结构，将一段区间不断二分下去，二分的一个区间作为其一个节点，另一个作为另一个节点，然后每个区间记录其左右边界的信息以及其它相关信息（根据题目来）

那么线段树将一个很长的区间变换为一个二叉树，所以相关查询的时间可以做到 $O(logn)$级别

**算法**

**pushup操作**

利用左右节点更新自身

**build操作**

建树

**modify操作**

更新操作，可以递归下去直到区间内只有自身节点，即可更新

**query操作**

查询一段区间的和

**代码模板**

这里以求区间和为例 [acwing.动态求连续区间和](https://www.acwing.com/problem/content/1266/)

```c++
#include <iostream>
#include <cstdio>
using namespace std;

const int N = 100010;

int w[N];
struct Node {
    int l, r;
    int sum;
}tr[N * 4];

// 用该节点的左右子节点更新
void pushup(int u) {
    tr[u].sum = tr[u * 2].sum + tr[u * 2 + 1].sum; 
}

// 建树
void build(int u,int l,int r) {
    
    if(l == r) tr[u] = {l,r,w[r]};
    else {
        tr[u] = {l,r};
        int mid = l + r >> 1;
        build(u << 1,l,mid), build(u << 1 | 1,mid + 1, r);
        pushup(u);
    }

}


// 查询某区间的和
int query(int u,int l,int r) {
    if(tr[u].l >= l && tr[u].r <= r) return tr[u].sum;
    int mid = tr[u].l + tr[u].r >> 1;
    int sum = 0;
    if(l <= mid) sum = query(u << 1,l,r);
    if(r > mid) sum += query(u << 1 | 1,l,r);
    return sum;
}

// 单点修改
void modify(int u,int x,int v) {
    if(tr[u].l == tr[u].r) tr[u].sum += v;
    else {
        int mid = tr[u].l + tr[u].r >> 1;
        if(x <= mid) modify(u << 1,x,v);
        else modify(u << 1 | 1,x,v);
        pushup(u);
    }
}

int main()
{
    int n, m;
    scanf("%d%d",&n,&m);
    
    for(int i = 1;i <= n;i ++) scanf("%d",&w[i]);
    
    build(1,1,n);
    
    while(m --) {
        int k, a, b;
        scanf("%d%d%d",&k,&a,&b);
        if(k == 0) printf("%d\n",query(1,a,b));
        else modify(1,a,b);
    }
    return 0;
}
```



### 堆

>堆是一种数据结构，可以以 O(1) 的复杂度找到集合中最小的点或者最大的点

对应 `c++` 中的 `priority_queue`(默认是大根堆)

`priority_queue<int, vector<int>, greater<int>>` 小根堆

**模拟堆**

```cpp
// h[N]存储堆中的值, h[1]是堆顶，x的左儿子是2x, 右儿子是2x + 1
// ph[k]存储第k个插入的点在堆中的位置
// hp[k]存储堆中下标是k的点是第几个插入的
int h[N], ph[N], hp[N], size;

void heap_swap(int a, int b) {
    swap(ph[hp[a]],ph[hp[b]]);
    swap(hp[a],hp[b]);
    swap(a,b);
}

void down(int u) {
    int t = u;
    if(u * 2 <= size && h[u * 2] < h[t]) t = u * 2;
    if(u * 2 + 1 <= size && h[u * 2 + 1] < h[t]) t = u * 2 + 1;
    if(u != t) {
       	heap_swap(u, t);
        down(t);
    }
}

void up(int u) {
    while(u / 2 && h[u] < h[u / 2]) {
        heap_swap(u, u / 2);
        u >>= 1;
    }
}

// O(n)建立堆
for(int i = size / 2;i >= 1;i --) down(i);
```



### 散列表(hash)

> 散列表就是哈希表，可以接近 O(1) 的复杂度查询

**模拟散列表**

```cpp
int h[N], e[N], ne[N], idx;

// 插入
void insert(int x) {
	int k = (x % N + N) % N;	// 将模值转为正数
    e[idx] = x;
    ne[idx] = h[k];
    h[k] = idx ++;
}

// 查找
bool find(int x) {
    int k = (x % N + N) % N;
    for(int i = h[k];i != -1;i = ne[i]) {
        if(e[i] == x) return true;
    }
    return false;
}
```



## 0x2 搜索与图论



### *DFS

> DFS，深度优先搜索，俗称暴搜，因为复杂度是指数级别的，dfs可以用来枚举各种情况，可以做全排列，图和树的遍历等问题

**思想**

DFS的思想在于从某一点递归的一直到最底层，然后回溯，从另一种情况搜索。因此可以在递归和回溯的过程中做一系列操作

经典例题：

[acwing.排列数字](https://www.acwing.com/problem/content/844/)

[acwing.n-皇后问题](https://www.acwing.com/problem/content/845/)

[acwing.树的重心](https://www.acwing.com/problem/content/848/)

时间复杂度：$O(2^n) (n为搜索树的高度 )$

#### 图和树的DFS

##### 关于数和图的存储

1. 邻接矩阵 $g[a][b]$ 存储边 a - > b
2. 邻接表

```cpp
// 对于每一个节点，都开一个单链表，存储该节点能走到的所有节点， h[N]存储的是单链表的头节点，
int h[N], e[N], ne[N], idx;

// 添加一条边
void add(int a,int b) {
    e[idx] = b, ne[idx] = h[a], h[a] = idx ++;
}

// 初始化
idx = 0;
memset(h, -1, sizeof h);
```

**图的DFS**

时间复杂度$O(n + m)$，$n$ 表示点数， $m$ 表示边数

```cpp
int dfs(int u) {
    st[u] = true;	// 表示 u 已经遍历过
    
    for(int i = h[u];i != -1;i = ne[i]) {
        int j = e[i];
        if(!st[j]) {
            dfs(j);
           	...
        }
    }
}
```



### *BFS

> BFS，广度优先搜索，基于队列实现

**思想**

广搜就是先将节点所连的边都存进队列中，根据队列的特征，最终的结果就是一层一层的遍历整个图，先步长为1的节点，再步长为2的节点，以此类推。**根据这个特性，如果边的权值是1，可以利用广搜，求出两点的最短路径**

典型例题：

[acwing.走迷宫](https://www.acwing.com/problem/content/846/)

[acwing.八数码](https://www.acwing.com/problem/content/847/)

[acwing.图中点的层次](https://www.acwing.com/problem/content/849/)

#### 图和树的BFS

**代码模板**

```cpp
queue<int> q;
st[1] = true; 	// 表示1号点已经被遍历

while(q.size()) {
	int t = q.front();
    q.pop();
    
    for(int i = h[t];i != -1;i = ne[i]) {
        int j = e[i];
        if(!st[j]) {
            st[j] = true;
            q.push(j);
            // 相关操作
        }
    }
}
```

### 

### 拓扑排序

> 拓扑排序类似于 流程图，需要先将图中每一点的前置任务都完成，才能进行该点的任务，换句话说，就是只能先完成入度为0的点

**思想**

基本思路就是对每个入度为0的点进行操作，然后将该点出边所连的点的入度减去 $1$ ，刷新图的入度

典型例题：

[acwing.有向图的拓扑序列](https://www.acwing.com/problem/content/850/)

时间复杂度：$O(n + m)$，$n$ 表示点数， $m$ 表示边数

**代码模板**

```cpp
bool topsort()
{
    int hh = 0, tt = -1;

    // d[i] 存储点i的入度
    for (int i = 1; i <= n; i ++ )
        if (!d[i])
            q[ ++ tt] = i;

    while (hh <= tt)
    {
        int t = q[hh ++ ];

        for (int i = h[t]; i != -1; i = ne[i])
        {
            int j = e[i];
            if (-- d[j] == 0)
                q[ ++ tt] = j;
        }
    }

    // 如果所有点都入队了，说明存在拓扑序列；否则不存在拓扑序列。
    return tt == n - 1;
}
```



### *最短路算法

#### 朴素 dijkstra

> dijkstra算法是求最短路径的算法之一，思想类似于bfs，是一层层的求出最短路径

**思想**

dijkstra的算法主要思想是维护一个`dis`数组，记录每一层起到到各个点的最短距离，维护一个`st`数组表示已经确认到某一点的最短路径的点集合

算法基本思路：

- 初始化dis数组为无穷大，`dis[原点] = 0`

- 找出dis中最小值，即从原点到某一点的最短路径
- 选出来后将其放入集合st，表示其已经被确认最短路径
- 利用该点，看是否可以通过该点，到其他点比直接从起点到其它点的距离更短，即边的“松弛”
- 重复上述步骤

**为什么每一次找到的最小值就是到该点的最短路径？**

拿找到的第一个点举例，我们的 `dis` 数组第一次就是找原点通过一条边，即直接连到某一点的距离，那么，找到 `dis` 中的最小值就是找到原点直接通过一条边能达到的最短距离，因为到其它点的距离都大于该值且 dijkstra 应用于边的值全为正数，所以无法通过某一点来间接到该点使得距离更短。所以每一次找到的 `dis` 中最小的值就是确定了到该点的最短距离

**更新`dis`数组多少次（循环多少次）？**

dijkstra 算法其实类似于bfs的思想，先是找到能通过一条边就能找到最短路径的点，再是通过两条边就能找到最短路径的点，以此类推。所以如果初始化到原点的距离为0，其它全为正无穷，那么第一次就是通过一条边就能找到最短路径的点，一条边，二条边.....。**那么总的次数就是节点的个数减一，即 n - 1**

**为什么 dijkstra 算法不能求出有负权边的最短路径？**

dijkstra 算法是建立在贪心的策略上,。利用局部最优来达到全局最优，既然是贪心的策略，那么此算法必定是“目光短浅”的，根据算法，每一次迭代就已经确定了一个点的最短路径，如果存在负权边，那么之前的那个点的最短路径也被更新，但是这个点已经在确认是最短路径的集合中，所以会导致答案错误。例如以下的例子，dijkstra 第一次迭代就已经确定了能通过一条边就达到的最短路径的点，那么 A ~ B 的最短路径确认为了 $3$，可是第二次迭代，B的最短路径又被更新为 $2$，此时 $2$ 才是最短的，但是 B 已经进入了确认最短路的集合中，所以导致答案错误

![dijkstra问题图1](https://cdn.jsdelivr.net/gh/OrdNire/notes/img/202112101435731.png)

典型例题：

[acwing.Dijkstra求最短路 I ](https://www.acwing.com/problem/content/851/)

时间复杂度：$O(n^2 + m)$ ，$n$ 表示点数，$m$ 表示边数

**代码模板**

```cpp
int g[N][N];  // 存储每条边，朴素dijkstra的节点数较少，可以利用稠密图
int dist[N];  // 存储1号点到每个点的最短距离
bool st[N];   // 存储每个点的最短路是否已经确定

// 求1号点到n号点的最短路，如果不存在则返回-1
int dijkstra()
{
    memset(dist, 0x3f, sizeof dist);
    dist[1] = 0;

    for (int i = 0; i < n - 1; i ++ )
    {
        int t = -1;     // 在还未确定最短路的点中，寻找距离最小的点
        for (int j = 1; j <= n; j ++ )
            if (!st[j] && (t == -1 || dist[t] > dist[j]))
                t = j;

        st[t] = true;	// 已经确定最小边，放入集合
        
        // 用t更新其他点的距离
        for (int j = 1; j <= n; j ++ )
            dist[j] = min(dist[j], dist[t] + g[t][j]);

    }

    if (dist[n] == 0x3f3f3f3f) return -1;
    return dist[n];
}
```



#### * 堆优化 dijkstra

> 容易知道找到最小值的点的复杂度是 $O(n)$ ，所以这一步可以动态的维护一个小根堆，可以将复杂度降到 $O(logn)$

**思想**

对找到dis中最小值的点下手优化，维护一个存有距离和点编号的小根堆即可

典型例题：

[acwing.Dijkstra求最短路 II](https://www.acwing.com/problem/content/852/)

时间复杂度：$O(mlogn)$ ，$n$ 表示点数，$m$ 表示边数

**代码模板**

```cpp
typedef pair<int, int> PII;

int n;      // 点的数量
int h[N], w[N], e[N], ne[N], idx;       // 邻接表存储所有边
int dist[N];        // 存储所有点到1号点的距离
bool st[N];     // 存储每个点的最短距离是否已确定

void add(int a, int b, int c) {
    e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx ++;
}

// 求1号点到n号点的最短距离，如果不存在，则返回-1
int dijkstra()
{
    memset(dist, 0x3f, sizeof dist);
    dist[1] = 0;
    priority_queue<PII, vector<PII>, greater<PII>> heap;
    heap.push({0, 1});      // first存储距离，second存储节点编号

    while (heap.size())
    {
        auto t = heap.top();
        heap.pop();

        int ver = t.second, distance = t.first;

        if (st[ver]) continue;
        st[ver] = true;

        for (int i = h[ver]; i != -1; i = ne[i])
        {
            int j = e[i];
            if (dist[j] > distance + w[i])
            {
                dist[j] = distance + w[i];
                heap.push({dist[j], j});
            }
        }
    }

    if (dist[n] == 0x3f3f3f3f) return -1;
    return dist[n];
}
```



#### * Bellman-ford

> dijkstra最短路径的算法只能解决边为正整数的情况，Bellman-ford算法可以解决边权为负数的情况

**思想**

bellman-ford 算法的主要思想其实是和 dijkstra 算法类似，也是类似于 bfs，它每一次的迭代的实际意义表示**最多能经过多少条边能确认的最短路径**

算法基本思路：

- 将所有的边存起来
- 迭代 $n$ 次，每次都类似于 dijkstra 算法的松弛操作，遍历所有的边，进行松弛操作
- 确认是否存在最短路径

**bellman-ford 算法为什么可以解决负权边且可以判断负环？**

因为bellman-ford 和 dijkstra 的差别在于 bellman-ford 每一次迭代更新最短路径的时候，并不会直接确定某一点的最短路径，后面的迭代照样继续计算路径，所以即使有负权边，照样可以得到正确答案。其次，算法中每一次迭代，实际含义都是最多经过几条边能确定的最短路径，那么如果单纯判断两点间的最短路径，那么迭代次数就是 $n - 1$，因为最多就根据 $n - 1$ 条边就能确认任意两点的最短路径。第 $n$ 次迭代，路径如果被更新，那么根据抽屉原理，$1 - n$ 最多就只有 $n - 1$ 条边，却经过 $n$ 条边还能被更新， 那么一定存在一个点被经过了两次，那么就形成了负环，所以bell-ford算法可以用来判定负环。

**bellman-ford 算法能应用于什么场景？**

bellman-ford 实际上是 dijsktra 算法的一种变种，可以解决负权边的最短路径问题，也可以判定负环，但是判定负环一般不用 bellman-ford，为什么时间复杂度太高，而是使用 spfa 算法，bellman-ford 算法典型应用场景就是 在最多能通过限制边数求最短路径的问题。

**如果限制了边数，为什么需要备份数组？**

因为 bellman-ford 的算法是一层一层递进更新的，如果不备份，就会出现下图这个情况，第一次迭代表示能通过一条边就到达的最短路径，但是不备份的情况下，第一次先更新 $2$ 号节点，然后到 23 这条边，又因为 1--2 被更新了，那么 3 号节点也被更新了，那么这一次迭代其实是让 3 号点通过了两条才更新的，违反了一层只能表示通过一条边更新最短路径，如果题目要求最多限制 $k$ 条边，那么这种情况就会出错，所以需要备份数组。

![bellman-ford问题图1](https://cdn.jsdelivr.net/gh/OrdNire/notes/img/202112101435667.png)

**为什么最后判断是否存在是大于 0x3f3f3f3f / 2 ？**

因为如果后面是负权边，那么实际上会比正无穷稍微小一点点，所以需要除以二。

典型例题：

[acwing.有边数限制的最短路](https://www.acwing.com/problem/content/855/)

时间复杂度：$O(nm)$ ，$n$ 表示点数，$m$ 表示边数

**代码模板**

```cpp
int n, m;       // n表示点数，m表示边数
int dist[N],backup[N];;        // dist[x]存储1到x的最短路距离, backup 数组作为备份数组（如果限制边数使用）

struct Edge     // 边，a表示出点，b表示入点，w表示边的权重
{
    int a, b, w;
}edges[M];

// 求1到n的最短路距离，如果无法从1走到n，则返回-1。
int bellman_ford()
{
    memset(dist, 0x3f, sizeof dist);
    dist[1] = 0;

    // 如果第n次迭代仍然会松弛三角不等式，就说明存在一条长度是n+1的最短路径，由抽屉原理，路径中至少存在两个相同的点，说明图中存在负权回路。
    for (int i = 0; i < n; i ++ )
    {
        memcpy(backup, dist, sizeof dist);	// 备份数组，确保每一次迭代都是基于上一次迭代的结果（如果限制边数使用）
        for (int j = 0; j < m; j ++ )
        {
            int a = edges[j].a, b = edges[j].b, w = edges[j].w;
            if (dist[b] > backup[a] + w)
                dist[b] = backup[a] + w;
        }
    }

    if (dist[n] > 0x3f3f3f3f / 2) return -1;
    return dist[n];
}
```



#### * spfa

> spfa 是对 bellman-ford 算法进行优化的算法，可以有效降低时间复杂度

**思路**

利用队列，如果某个点已经被更新，那么加入队列，等待下次再次利用该点更新

算法的基本思路（保证不存在负权回路）：

- 如果队列不空，那么取出队头，利用该点更新所有连接该点的点的最短路径
- 如果某个点被更新，加入队列

**spfa 为什么对 bellman-ford 优化了？**

bellman-ford 算法就是反正最多 $n - 1$ 次就更新完所有点的最短路径，那么每一次迭代就直接一股脑遍历所有的边来更新，但是bellman-ford中，如果某一点在一次迭代中没有被更新最短路径，那么表示它其实不能再被松弛，以后再更新该点是没有意义的，因为它已经被确认了最短路径。利用这一点，可以用队列，只存被更新了点，之后再以被更新的点来更新其他点的最短路径，那么能有效降低时间复杂度。

**st 数组用来干什么？**

已经加入队列的点需要标记以下，如果重复加入队列是没有意义的

典型例题：

[acwing.spfa求最短路](https://www.acwing.com/problem/content/853/)

时间复杂度：平均情况下 $O(m)$ ，最坏情况下 $O(nm)$，$n$ 表示点数，$m$ 表示边数

**代码模板（保证不存在负权回路）**

```cpp
int n;      // 总点数
int h[N], w[N], e[N], ne[N], idx;       // 邻接表存储所有边
int dist[N];        // 存储每个点到1号点的最短距离
bool st[N];     // 存储每个点是否在队列中

// 求1号点到n号点的最短路距离，如果从1号点无法走到n号点则返回-1
int spfa()
{
    memset(dist, 0x3f, sizeof dist);
    dist[1] = 0;

    queue<int> q;
    q.push(1);
    st[1] = true;

    while (q.size())
    {
        auto t = q.front();
        q.pop();

        st[t] = false;

        for (int i = h[t]; i != -1; i = ne[i])
        {
            int j = e[i];
            if (dist[j] > dist[t] + w[i])
            {
                dist[j] = dist[t] + w[i];
                if (!st[j])     // 如果队列中已存在j，则不需要将j重复插入
                {
                    q.push(j);
                    st[j] = true;
                }
            }
        }
    }

    if (dist[n] == 0x3f3f3f3f) return -1;
    return dist[n];
}
```



**spfa 判断负环**

利用 spfa 判断负环利用的也是抽屉原理，因为 spfa 是 bellman-ford 的一个优化，所以可以存储每一个节点需要经过几条边达到最短路径，因为在没有负环的条件下，每个节点最多需要 $n - 1$ 条边，如果有 $n$ 条边，代表存在负环

**为什么 spfa 判断负环需要初始把所有点加入队列？**

因为图不一定是强连通图，如果不是强连通国，那么也许存在某一点到另一点有负环，而另外一点到该点没有负环，所以需要判断以所有点为起始点，这也是为什么时间复杂度变高的原因

**为什么不需要初始化 dis？**

因为并不知道以哪个点为起点，而且如果存在负环，路径是会小于零，所以不必要初始化 dis 数组

时间复杂度 ：$O(nm)$ ，$n$ 表示点数，$m$ 表示边数

**代码模板**

```cpp
int n;      // 总点数
int h[N], w[N], e[N], ne[N], idx;       // 邻接表存储所有边
int dist[N], cnt[N];        // dist[x]存储1号点到x的最短距离，cnt[x]存储1到x的最短路中经过的点数
bool st[N];     // 存储每个点是否在队列中

// 如果存在负环，则返回true，否则返回false。
bool spfa()
{
    // 不需要初始化dist数组
    // 原理：如果某条最短路径上有n个点（除了自己），那么加上自己之后一共有n+1个点，由抽屉原理一定有两个点相同，所以存在环。
    //      换句话说，如果到一个点最多只有 n - 1 条边，如果到一个点有 n 条以上的边，那么就表示图中存在负环

    queue<int> q;
    for (int i = 1; i <= n; i ++ )
    {
        q.push(i);
        st[i] = true;
    }

    while (q.size())
    {
        auto t = q.front();
        q.pop();

        st[t] = false;

        for (int i = h[t]; i != -1; i = ne[i])
        {
            int j = e[i];
            if (dist[j] > dist[t] + w[i])
            {
                dist[j] = dist[t] + w[i];
                cnt[j] = cnt[t] + 1;
                if (cnt[j] >= n) return true;       // 如果从1号点到x的最短路中包含至少n个点（不包括自己），则说明存在环
                if (!st[j])
                {
                    q.push(j);
                    st[j] = true;
                }
            }
        }
    }

    return false;
}
```



#### *Floyd 

> Floyd 算法基于动态规划 而来的一种多源最短路问题

算法基本思路：

- 枚举 $k$ 作为中转点
- 枚举始末两点
- 更新距离

时间复杂度 ：$O(n^3)$ ，$n$ 表示点数

**代码模板**

```cpp
初始化：
    for (int i = 1; i <= n; i ++ )
        for (int j = 1; j <= n; j ++ )
            if (i == j) d[i][j] = 0;
            else d[i][j] = INF;

// 算法结束后，d[a][b]表示a到b的最短距离
void floyd()
{
    for (int k = 1; k <= n; k ++ )
        for (int i = 1; i <= n; i ++ )
            for (int j = 1; j <= n; j ++ )
                d[i][j] = min(d[i][j], d[i][k] + d[k][j]);
}
```



### *最小生成树



#### 朴素prim算法

> prim算法是求最短路的一种算法，利用的是贪心的策略

prim算法需要一个集合表示已经在生成树中的点，这里记为 st

算法基本思路：

- 在不在集合中的所有点中，找到离生成树最近的点
- 该点加入集合
- 利用该点更新所有连接该点的不在集合中的点，“松弛”操作
- 重复上述步骤

**prim算法的循环次数是多少？**

prim算法的每一次循环的意义是确认了某一点加入最小生成树的集合中，所以只需要循环 n 次表示加入集合中的点数为总点数

**如何判断没有最小生成树？**

如果某一次选中加入的点的距离是正无穷，那么表示图不连通，即无法找到最小生成树



典型例题：[acwing.Prim算法求最小生成树](https://www.acwing.com/problem/content/description/860/)

时间复杂度 ：$O(n^2)$ ，$n$ 表示点数

**代码模板**

```c++
#include <iostream>
#include <cstring>
using namespace std;

const int N = 510, INF = 0x3f3f3f3f;
int g[N][N];
int dist[N];
bool st[N];
int n,m;

int prim(){
    memset(dist, 0x3f, sizeof dist);
    dist[1] = 0;
    
    int res = 0;
    for(int k = 0;k < n;k ++) {
        
        int t = -1;
        for(int i = 1;i <= n;i ++)
            if(!st[i] && (t == -1 || dist[i] < dist[t]))
                t = i;
        
        st[t] = 1;
        if(dist[t] == INF) return INF;
        res += dist[t];
        
        for(int i = 1;i <= n;i ++)
            dist[i] = min(dist[i], g[t][i]);
        
    }
    
    return res;
}

int main()
{
    scanf("%d%d",&n,&m);
    
    memset(g, 0x3f,sizeof g);
    while(m --){
        int a, b, c;
        scanf("%d%d%d",&a,&b,&c);
        g[a][b] = g[b][a] = min(g[a][b],c);
    }
    
    int t = prim();
    if(t == INF) puts("impossible");
    else printf("%d\n",t);
    
    return 0;
}
```



#### *kruskal

> kruskal算法是基于并查集的最短路算法，时间复杂度比朴素版prim算法低，为常用算法

算法基本思路：

- 将边排序
- 历遍边，判断边连接的两点是否在同一个连通块中，如果不在，则加入
- 集合中加入的边的权值和即为最小生成树的和

kruskal算法的时间复杂度的瓶颈是排序，所以时间复杂度只有 $$O(nlogn)$$，但不能解决需要记录路径的最小生成树问题

典型例题：[acwing.Kruskal算法求最小生成树](https://www.acwing.com/problem/content/861/)

时间复杂度：$O(nlogn)$

**代码模板**

```c++
#include <iostream>
#include <cstring>
#include <algorithm>
using namespace std;

const int N = 200010;
struct Edge {
    int a, b;
    int w;
    bool operator< (const Edge &t) const {
        return w < t.w;
    }
}edge[N];

int p[N];

int find(int x) {
    if(p[x] != x) p[x] = find(p[x]);
    return p[x];
}

int main()
{
    int n, m;
    scanf("%d%d", &n, &m);
    
    for(int i = 1;i <= n;i ++) p[i] = i;

    for(int i = 0;i < m;i ++) {
        int a, b, c;
        scanf("%d%d%d", &a, &b, &c);
        edge[i] = {a, b, c};
    }
    
    sort(edge, edge + m);
    
    int res = 0, cnt = 0;
    for(int i = 0;i < m;i ++) {
        int a = edge[i].a, b = edge[i].b, w = edge[i].w;
        a = find(a), b = find(b);
        if(a != b) {
            p[a] = b;
            res += w;
            cnt ++;
        }
    }
    
    // 加入的边少于 n - 1 条，表示图不连通
    if(cnt < n - 1) puts("impossible");
    else printf("%d\n", res);
    
    return 0;
}
```



### 二分图

> 二分图也称二部图，就是图中的点都可以分为两部分，且这两部分之间有边相连而内部无边相连

性质：二分图成立的条件必须满足无奇数环

![二分图01](https://cdn.jsdelivr.net/gh/OrdNire/notes/img/202112101435965.png)



如图，假设按照二分图定义，1表为一种颜色，2表为另一种颜色，那么交错染色表示点分别在两边，如果是奇数边，那么会出现到最后染的颜色矛盾



#### 染色法判断二分图

算法思想：
染色法判断二分图就是从定义出发，对每一个节点，遍历其所有的子节点，染上和自己不同的颜色，如果有颜色已经染色且颜色和本身一致，那么不是二分图

时间复杂度：$O(n + m)$

**代码模板**

```c++
#include <iostream>
#include <cstring>
#include <algorithm>
using namespace std;

const int N = 100010, M = N * 2;
int h[N], e[M], ne[M], idx;
int color[N];
int n, m;

void add(int a, int b) {
    e[idx] = b, ne[idx] = h[a], h[a] = idx ++;
}

bool dfs(int u,int c) {
    color[u] = c;
    
    for(int i = h[u];i != -1;i = ne[i]) {
        int j = e[i];
        if(!color[j]) {
            if(!dfs(j, 3 - c)) return false;
        }
        else if(color[j] == c) return false;
    }
    return true;
}

int main()
{
    scanf("%d%d", &n, &m);
    memset(h, -1, sizeof h);
    while(m --) {
        int a, b;
        scanf("%d%d", &a, &b);
        add(a, b), add(b, a);
    }
    
    bool flag = true;
    for(int i = 1;i <= n;i ++)
        if(!color[i]) {
            if(!dfs(i, 1)) {
                flag = false;
                break;
            }
        }
    
    if(!flag) puts("No");
    else puts("Yes");
    return 0;
}
```



#### 匈牙利算法

> 匈牙利算法是求二分图的一个最大匹配的算法，时间复杂度为 $O(nm)$

二分图匹配和最大匹配的定义：

>二分图的匹配：给定一个二分图 $G$，在 $G$ 的一个子图 $M$ 中，$M$ 的边集 ${E}$ 中的任意两条边都不依附于同一个顶点，则称 $M$ 是一个匹配。
>
>二分图的最大匹配：所有匹配中包含边数最多的一组匹配被称为二分图的最大匹配，其边数即为最大匹配数。

算法思路：

该算法也可以戏称为“渣男算法”

- 遍历左半部的每一个点
- 对每一个点所连的点（右半部分），找到其是否匹配
- 如果不匹配，则看该点匹配的点（左半部分的点）是否能找到下一个能与之匹配的点
- 如果能则将其换一个点匹配，原来左半部分的点和这个右半部分的点匹配

典型例题：

[acwing.二分图的最大匹配](https://www.acwing.com/problem/content/863/)

时间复杂度：$O(nm)$，实际上运行的时间一般小于 $O(nm)$

**算法模板**

```c++
#include <iostream>
#include <cstring>
using namespace std;

const int N = 100010;
int h[N], e[N], ne[N], idx;
int match[N];
bool st[N];

void add(int a, int b) {
    e[idx] = b, ne[idx] = h[a], h[a] = idx ++;
}

int n1, n2, m;

bool find(int x) {
    
    for(int i = h[x];i != -1;i = ne[i]) {
        int j = e[i];
        if(!st[j]) {
            st[j] = 1;
            if(match[j] == 0 || find(match[j])) {
                match[j] = x;
                return true;
            }
        }
    }
    return false;    
}

int main()
{
    scanf("%d%d%d", &n1, &n2, &m);
    memset(h, -1, sizeof h);
    while(m --) {
        int a, b;
        scanf("%d%d", &a, &b);
        add(a, b);
    }
    
    int res = 0;
    for(int i = 1;i <= n1;i ++) {
        memset(st, 0, sizeof st);
        if(find(i)) res ++;
    }
    
    printf("%d\n", res);
    
    
    return 0;
}
```





## 0x3 数论

### *质数

**算术基本定理**

> 任何一个大于1的 **自然数** $N$ ,如果 $N$ 不为 **质数**，那么 $N$可以唯一分解成有限个**质数**的乘积 $N = P_1^{a_1}P_2^{a_2}P_3^{a_3}......P_n^{a_n}，$这里 $P_1<P_2<P_3......<P_n$均为 **质数**，其中指数 $a_i$ 是正整数, 质数本身会被分解为自己，所以自然数都可以被分解为自然数的乘积



#### 分解质因子

> 根据算术基本定理，可以对自然数分解质因子

时间复杂度：$O(sqrt(n))$ 

**代码模板**

```cpp
void divide(int n) {
    for(int i = 2;i <= n / i;i ++) {
		if(n % i == 0) {
            int p = i;
            int a = 0;
            while(n % i == 0) {
                a ++;
                n /= i;
            }
            printf("%d %d\n",p,a);
        }
    } 
    if(n > 1) printf("%d %d\n",n,1);
}
```

对分解质因子的相关解释：

- 每个自然数的质因子最多只有一个是大于 $sqrt(n)$ 的，所以我们只需要枚举到 $sqrt(n)$ 即可
- 枚举的时候能整除 $n$ 的必定是质数，因为假设枚举到 $i$，那么前 $i - 1$ 的数已经被除掉，即如果 $i | n$，那么 $i$ 就不包含因子，即 $i$ 必定为质数



#### 质数筛

> 质数筛法有两种常用筛法，埃氏筛法和线性筛，而最常用的是线性筛，其中线性筛还可以求出每个数的最小质因子

**埃氏筛法**

```cpp
// st[N] 为是否是合数，primes[N]存放质数
void sieve_primes(int n) {
	for(int i = 2;i <= n;i ++) {
		if(!st[i]) {
            primes[cnt ++] = i;
            for(int j = i * 2;j <= n;j += i)
                st[j] = true;
        }
    }
}
```



**线性筛**

```cpp
int primes[N], cnt;     // primes[]存储所有素数
bool st[N];         // st[x]存储x是否被筛掉
int minp[N];		// 每个数的最小质因子

void linear_primes(int n) {
    for(int i = 2;i <= n;i ++) {
        if(!st[i]) {
            primes[cnt ++] = i;
        	minp[i] = i;
        }
        for(int j = 0;primes[j] * i <= n;j ++) {
            st[primes[j] * i] = true;
            minp[primes[j] * i] = primes[j];
            if(i % primes[j] == 0) break;
        }
    }
}
```

对线性筛的相关解释：

- 线性筛每次筛选是利用最小的质因子筛掉的每一个数，且每个数只会被筛选一次，所以可以存储每个数的最小质因子



### *约数

#### gcd 算法（欧几里得算法）

> gcd也称欧几里得算法就是求两个数最大公约数

**代码模板**

```cpp
int gcd(int a, int b) {
    return b ? gcd(b, a % b) : a;
}
```



#### 约数的个数

> 根据算术基本定理，每个数都可以分解为质因子的乘积，所以有求每个自然数约数个数的公式

求约数个数的公式为：

$(a_1 + )(a_2 + 1)(a_3 + 1)(a_4 + 1)...(a_k + 1)，a_i为自然数每个质因子的次数$

所以求约数的个数可以采用分解质因子的算法求出每个质因子的次数，再相加



#### 约数的和

求约数和的公式为：

$(p_1^0 + p_1^1 + p_1^2 + ... + p_1^{a_1})(p_2^0 + p_2^1 + p_2^2 + ... + p_2^{a_2})...(p_n^0 + p_n^1 + p_n^2 + ... + p_n^{a_n})，p_i为质因子，a_i为其指数$

所以同样可以利用分解质因子求出所有数的约数和

求和可以采用秦九邵算法

```cpp
for(auto& prime : primes){
    int p = prime.first, a = prime.second;
    LL t = 1;
    while(a --) t = (t * p + 1) % mod;  //秦九韶算法
    res = res * t % mod;
}
```



### *快速幂

> 快速幂是一种以$O(logn)$的时间复杂度求一个数的幂次方的算法

**核心思想**

因为指数可以利用二进制表示

假设一个数 $3^6$，那么可以表示为 $3^{(110)_2}，3^{2^2+2^1}，3^{2^2}*3^{2^1}，3^4*3^2$

所以我们可以利用二进制的想法，如果指数当前位为 $1$ 则乘以一个底数，而底数初始就是 $3$，每一次查看指数的某一位，底数平方

```cpp
typedef long long LL;
LL qmi(int a, int b, int p) {
    LL res = 1 % p;
    while(b) {
        if(b & 1) res = (LL)res * a % p;
        a = (LL)a * a % p;
        b >>= 1;
    }
    return res;
}
```



### *扩展欧几里得算法

> 扩展欧几里得算法其实就是利用欧几里得的递推公式，可以求出二元不定方程的解



**裴蜀定理**

> 若 $a,b$  是整数,且 $gcd(a,b)=d$，那么对于任意的整数 $x,y,ax+by$都一定是 $d$ 的倍数，特别地，一定存在整数 $x,y$，使 $ax+by=d$ 成立。

即如果二元不定方程有解，那么对于 $ax + by = c$，$d|c$

那么我们可以利用扩展欧几里得算法，求出一组解

公式推导：

$gcd(a,b) = gcd(b,a mod b)$

$ax + by = by + (amodb)x$

$by + (a - a/b*b)x = -ax + b(y - a/b*x)$

所以 $x = x, y = y - a/b*x$

所以 求 $gcd$ 的过程中，可以递归的求出​ $x,y$ ，利用回溯回来的 $x,y$，套用上述公式即可

```cpp
int exgcd(int a, int b, int &x, int &y) {
    if(!b) {
        x = 1, y = 0;
        return a;
    }
    int d = exgcd(b, a % b, y, x);
    y -= a / b * x;
    return d;
}
```

但是我们求出来的是，$ax + by = gcd(a,b)$，假设有解，那么 原二元不定方程的解是 需要再乘以 $c / d$

**特别的：**

记扩展欧几里得求出来的一组解为 $x_0,y_0$

那么二元不定方程 $ax + by = gcd(a,b)$ 的通解为：

$x = x_0 + kb$

$y = y_0 - ka$

所以如果需要求出一组最小的整数解，那么答案就是 $x = x_0mod(b/d)$



线性同余方程也能转换为求解二元不定方程的题

典型例题:

[acwing.五指山](https://www.acwing.com/problem/content/1301/)



## 0x4 动态规划

### 背包问题

背包问题简单来说就是限定体积，给定一系列有价值的物品，求如何拿物品使得在限定的体积内价值达到最大。

根据题目来确定体积和价值，而根据物品的选择方式，分为以下几类基本的背包问题：

- 01背包（选一次）
- 完全背包（选无限次）
- 多重背包（选有限次）
- 分组背包（每组物品挑一个）



#### 01 背包

01背包就是给定的物品只能选择一次

**状态表示：**`f[i][j]`表示从前 i 个物品中选，体积不超过 j 的最大价值

**转移分析（集合划分）：**

`f[i][j]`根据最后一次的状态，可以选择选第 i 种物品和不选第 i 种物品

- 不选：`f[i][j] = f[i - 1][j]`		不选就直接从第 i - 1 的状态转移过来，并且没选，体积也不变
- 选： `f[i][j] = f[i - 1][j - v[i]] + w[i] (j >= v[i])`		选择就从第 i - 1 的状态转移过来并且因为选择了，体积减去第 i 种物品的体积，还需要加上第 i 种物品的价值

**转移方程：**

`f[i][j] = max(f[i - 1][j], f[i - 1][j - v[i]] + w[i])`

那么实际做的时候就枚举物品 i 以及给定最大体积范围内的每一个体积，做转移

**伪代码**：

```c++
memset(f, 0, sizeof f);	// f[0][j] 不管j多大，含义是不超过j的最大价值，那么f[0][j] (j = 0,1,2...)为0
for(int i = 1;i <= n;i ++) {
    for(int j = 0;j <= m;j ++) {
        f[i][j] = f[i - 1][j];	// 不选
        if(j >= v[i])
            f[i][j] = max(f[i - 1][j - v[i]] + w[i]);	// 选
    }
}
```

咱们可以优化掉一维空间，可以看出 `f[i][j]` 都是从 `f[i - 1][j]` 转移过来，那么我们可以直接用`f[j]`来做，用迭代的上一次结果表示`f[i - 1]`。但要注意`f[i][j] = max(f[i - 1][j - v[i]] + w[i])`，如果我们从小到大枚举`j - v[i]`先用的是小的值，而我们又是从小到大枚举 j ，那么实际意义就是 `f[i][j] = max(f[i][j - v[i]] + w[i])`，所以我们需要改为从大到小枚举，可以让它用的值是上一次的结果

**优化（常用）**：

```c++
memset(f, 0, sizeof f);
for(int i = 1;i <= n;i ++) {
    for(int j = m;j >= v[i];j --)
        f[j] = max(f[j], f[j - v[i]] + w[i]);
}
```



#### 完全背包

完全背包，物品可以选择无限多次

**状态表示：**`f[i][j]`表示前 i 个物品中选，体积不超过 j 的最大价值

**状态分析（集合划分）**：

- 不选：`f[i][j] = f[i - 1][j]`
- 选：`f[i][j] = max(f[i][j], f[i - 1][i - 1 * v] + 1 * w, f[i - 1][i - 2 * v] + 2 * w, ..., f[i - 1][i - l * v] + k * w) (j >= k * v)`		因为可以选无限多个，所以可以尝试选0个，选1个，一直到选k个，k * v <= j

**状态转移：**

`f[i][j] = max(f[i - 1][j - 0 * v] + 0 * w, f[i - 1][j - 1 * v] + 1 * w, ... , f[i - 1][j - k * v] + k * w)`

**伪代码：**

```c++
memset(f, 0, sizeof f);
for(int i = 1;i <= n;i ++) {
    for(int j = 0;j <= m;j ++) {
        for(int k = 0;k * v[i] <= j;k ++)
            f[i][j] = max(f[i][j], f[i - 1][j - k * V[i]] + k * w[i]);
    }
}
```

因为是复杂度是$O(n^3)$，大部分会超时，所以可以优化掉一层循环和一维空间

`f[i][j] = max(f[i - 1][j - 0 * v] + 0 * w, f[i - 1][j - 1 * v] + 1 * w, f[i - 1][j - 2 * v] + 2 * w,....)`

`f[i][j - v] = max(                         f[i - 1][j - 1 * v],         f[i - 1][j - 2 * v] + 1 * w,....)`

我们可以发现，`f[i][j]`max后面部分可以通过`f[i][j - v]`转移过来，上面两个等式一综合：

`f[i][j] = max(f[i - 1][j], f[i][j - v] + w)`

然后再优化空间，可以发现`f[i][j]`是由`f[i - 1][j]`迭代过来，所以可以优化掉第一维，但是同时发现max第二项`f[i][j - v] + w`用的是第 i 层的值，那么我们就不能从大到小枚举，而需要从小到大枚举，因为我们需要用到本层的值

**优化（常用）：**

```c++
memset(f, 0, sizeof f);
for(int i = 1;i <= n;i ++) {
    for(int j = v[i];j <= m;j ++)
        f[j] = max(f[j], f[j - v[i]] + w[i]);
}
```

优化后时间复杂度为$O(n^2)$



#### 多重背包

多重背包，物品最多只能选择限定个

**状态表示：**`f[i][j]`表示前 i 个物品中选，体积不超过 j 的最大价值

**状态分析（集合划分）**：

- 不选：`f[i][j] = f[i - 1][j]`
- 选：`f[i][j] = max(f[i][j], f[i - 1][i - 1 * v] + 1 * w, f[i - 1][i - 2 * v] + 2 * w, ..., f[i - 1][i - l * v] + k * w) (j >= k * v && k <= s[i])`		可以尝试选0个，选1个，一直到选k个，k * v <= j 并且 k <= s[i]

**状态转移：**

`f[i][j] = max(f[i - 1][j - 0 * v] + 0 * w, f[i - 1][j - 1 * v] + 1 * w, ... , f[i - 1][j - k * v] + k * w)`

**伪代码**：

朴素版本：

```c++
memset(f, 0, sizeof f);
for(int i = 1;i <= n;i ++) {
    for(int j = 0;j <= m;j ++) {
        for(int k = 0;k <= s[i] && k * v[i] <= j;k ++) {
            f[i][j] = max(f[i][j], f[i - 1][j - k * v[i]] + k * w[i]);
        }
    }
}
```

时间复杂度为$O(nms)$

**优化**：

多重背包问题无法像完全背包问题那样优化

当有物品限制的情况下：

`f[i][j] =     max(f[i - 1][j], f[i - 1][j - v] + w, f[i - 1][j - 2v] + 2w,..,f[i - 1][j - sv] + sw)`

`f[i][j - v] = max(             f[i - 1][j - v],     f[i - 1][j - 2v] + w,...,f[i - 1][j - sv] + (s - 1)w, f[i - 1][j - (s + 1)v] + sw)`

可以看出，式子中`f[i][j - v]`的最后两项其实是不和`f[i][j]`相等的，所以即使我们知道`f[i - 1][j - (s + 1)v] + sw`的值，也无法确定整个的最大值，从而无法像完全背包那样转移过来。

**二进制优化（当s比较大时）**

当 s 比较大时，$O(nms)$的复杂度会超时，所以需要考虑优化

二进制优化方式其实就是考虑，我们每一次循环都需要枚举每种物品选 0 ~ s[i] 个，我们可以考虑利用二进制的性质

设 $k, 2^k <= s$，那么我们一定可以凑出 $0$ 到 $2^k - 1$ 中的所有值

例如：取 s = 9, 那么 $2^3 = 8 <= 9$，那么 k = 3，所以$2^3$的二进制为 1000，那么所有小于等于 1000 - 1 = 0111 的值都可以根据二进制凑出来，那么我们就有了 0 ~ $2^k - 1$ 的值，剩下取 c = s - $(2^k - 1)$，就可以凑出 0 - s 的所有值，(0 + c ~ $2^k - 1$ + c)

这样我们就可以对用法2的倍数来拆分 s，例如 s = 9(B=1001) = 7(B=0111) + 2(B=0010)，就可以用 1, 2, 4, 2 个s一组来拆分 s，这样这个问题就化归为了01背包问题

优化后的时间复杂度为 $O(nmlogs)$

**优化代码：**

```c++
int v[i], w[i];
int cnt;

// 拆分s部分
for(int i = 0;i < n;i ++) {
    int a, b, s;
    cin >> a >> b >> s;
    int k = 1;
    while(k <= s) {
        cnt ++;
        v[cnt] = k * a;
        w[cnt] = k * b;
        s -= k;
        k *= 2;
	}
    if(s > 0) {
        cnt ++;
        v[cnt] = s * a;
        w[cnt] = s * b;
    }
}

// 01背包部分
memeset(f, 0, sizeof f);
for(int i = 1;i <= cnt;i ++) {
    for(int j = m;j >= v[i];j --)
        f[j] = max(f[j], f[j - v[i]] + w[i]);
}
```



**单调队列的优化(时间复杂度优化到$O(nm)$)**

假设我们限制了k个物品

`f[i][j] = max(f[i - 1][j], f[i - 1][j - v] + w, f[i - 1][j - 2v] + 2w,..,f[i - 1][j - kv] + kw)`

因为从上一层转移过来，所以我们可以调整循环顺序来优化一维

`f[m] --> f[0]`:

`f[m] = max(f[m], f[m - v] + w, f[m - 2v] + 2w, f[m - 3v] + 3w, f[m - 4v] + 4w,...)`

那么我们可以讲上面写成下面这种形式：

`f[0] --> f[m]`:

`f[0], f[v], f[2v], f[3v], .. , f[kv]`

`f[1], f[v+1], f[2v+1], f[3v+1], .. , f[kv+1]`

`f[2], f[v+2], f[2v+2], f[3v+2], .. , f[kv+2]`

...

`f[j], f[v+j], f[2v+j], f[3v+j], .. ,f[kv+j]`

容易知道，kv+j == m，所以，我们可以讲其分为j类，并且每一类中的值都是在类之间进行转移。例如，`f[kv+j]`只依赖于`{f[j], f[v+j], .. ,f[3v+j], f[kv+j]}`

并且我们需要求的是`{f[j], f[v+j], .. ,f[3v+j], f[kv+j]}`中的最大值，那么我们可以利用单调队列来求动态维护其中的最大值，因为分为 j 类，那么就是 j 个单调队列。

**但是，我们还需要考虑偏移量的问题**

`f[j] = f[j]`
`f[j+v] = max(f[j] + w, f[j+v])`
`f[j+2v] = max(f[j] + 2w, f[j+v] + w, f[j+2v])`
`f[j+3v] = max(f[j] + 3w, f[j+v] + 2w, f[j+2v] + w, f[j+3v])`

我们可以对每一项提出一个kw，上式就变为：

`f[j] = f[j]`
`f[j+v] = max(f[j], f[j+v] - w) + w`
`f[j+2v] = max(f[j], f[j+v] - w, f[j+2v] - 2w) + 2w`
`f[j+3v] = max(f[j], f[j+v] - w, f[j+2v] - 2w, f[j+3v] - 3w) + 3w`

那么我们队列维护的时候，入队的值为 `f[j+kv] - kw` ，既维护一个`-kw`的偏移量，求最大值就是max()中的最大值，既单调队列的队首 + `kw`

**代码**

```c++
#include <iostream>
#include <cstring>
#include <algorithm>
using namespace std;

const int N = 20010;
int f[N], pre[N], q[N];
int n, m;

int main() {
    cin >> n >> m;
    for(int i = 0;i < n;i ++) {
        int v, w, s;
        cin >> v >> w >> s;
        memcpy(pre, f, sizeof f);	// 备份
        for(int j = 0;j < v;j ++) {
            int hh = 0, tt = -1;
            for(int k = j;k <= m;k += v) {
                if(hh <= tt && q[hh] < k - s * v) hh ++;
                
                // (q[tt] - j) / v == k
                while(hh <= tt && pre[q[tt]] - (q[tt] - j) / v * w <= pre[k] - (k - j) / v * w)
                    tt --;
                
                if(hh <= tt) 
                    f[k] = max(f[k], pre[q[hh]] + (k - q[hh]) / v * w);
                q[++ tt] = k;
            }
        }
    }
    cout << f[m] << endl;
    return 0;
}
```



#### 分组背包

分组背包是分为了物品组，且组内的物品最多只能选择一个。

分组背包问题就是组内物品为01背包问题

**代码**

```c++
for(int i = 1;i <= n;i ++)
    for(int j = m;j >= 0;j --)
        // s[i] 为组内物品的数量
        for(int k = 0;k < s[i];k ++)
            if(v[i][k] <= j)
                f[j] = max(f[j],f[j - v[i][k]] + w[i][k]);
```





#### 背包问题的初始化问题

- 从前 i 个物品中选，体积**最大为 j** 的最大价值

  ​	`f[i] = 0, 0 <= i <= m`

- 从前 i 个物品中选，体积**恰好为 j** 

  ​	求最大价值：`f[0] = 0, 其它为 -INF`

  ​	求最小价值：`f[0] = 0, 其它为 +INF`

- 从前 i 个物品中选，体积**至少为 j** 的最小价值

  ​	`f[0] = 0, 其它为 +INF`

上面可以从实际的角度理解，例如体积最大为 j 的最大价值，当一个物品都不选的时候，不管体积最大为多少，最大价值都是0。

