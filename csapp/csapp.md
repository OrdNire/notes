# 第七章 - 链接

> 链接是将不同的目标文件合成为一个可执行文件

**链接的目的**：

1. 链接可以将源文件分模块进行编译，**模块化**（目标文件）
2. 如果有模块需要更新，不必重新编译整个文件，只需要重新编译更新的文件，再链接为整个文件，**提高效率**



**链接的步骤**：

1. **符号解析（全局变量和函数）**，符号引用和符号定义相关联
2. **重定位**



链接的单元是目标文件，目标文件由编译器编译产生，在Linux中为 .o 后缀的名字

**目标文件的三种形式**：

- 可重定位目标文件
- 可执行目标文件
- 共享目标文件

目标文件的结构（定义为一个结构体）：

![ELF_struct](D:\个人资料\Notes\csapp\img\ELF_struct.png)

其中ELF中详细 section 的含义可见书 P467

**.text**		代码
**.data**	   已初始化的全局变量和静态C变量
**.bss**		 未初始化的全局变量和静态C变量，以及所有被初始化为0的全局或静态变量

可以利用 GNU READELF程序查看目标文件中的符号被分配在哪些字段

> readelf -a m.o	查看

![elf_sym](D:\个人资料\Notes\csapp\img\elf_sym.png)

其中Ndx为符号被分配到 section 中的索引，结合ELF中的段来看。其中有些特殊的伪节：

- UNDEF 代表未定义的符号，本目标模块引用，却在其它地方定义的符号
- COMMON 未被分配位置的未初始化的数据目标

COMMON和.bss的区别：

- COMMON：未初始化的全局变量
- 未初始化的静态变量，以及初始化为0的全局或静态变量

为什么或有这些区别？可查看链接器的符号解析原理



### 符号解析

链接器的输入是一组模块，每一组模块都有其符号。符号解析就是将模块中对符号的引用和其在其它模块中的该符号定义相关联。

**多重定义的全局符号**

对于多重定义的符号，定义函数和已初始化的全局变量为**强符号**，未初始化的全局变量为**弱符号**。链接器在选择符号时，有以下**规则**：

1. **不允许多个强符号同名**	如果有则报错
2. **如果一个强符号和多个弱符号同名，选择强符号**
3. **如果多个弱符号同名，任选一个**

 

### 重定位

当链接器完成符号解析后，就需要将其引用和定义关联起来。因为每个目标文件的代码和变量都是偏移量，无法直接加载进内存。

重定位后，目标文件就都合成为一个可执行文件，可以直接加载进内存。

![重定位](D:\个人资料\Notes\csapp\img\重定位.png)

有了可执行文件，就可以直接加载进内存中

![重定位加载进内存](D:\个人资料\Notes\csapp\img\重定位加载进内存.png)



由此可见，其中的全局变量和静态变量都加载进.data和.bss的读/写段中，而C局部变量编译器无法得知，只有在运行时堆栈上得知。而堆区则为 malloc 申请的内存区域。

**注意：在链接时候，链接器的算法总是从左至右顺序链接目标文件：**

解析第一个目标文件， 如果其中有符号引用，则先放入一个集合，如果后面的目标文件有其定义，则放入关联成功的集合中。如果解析完毕后仍有符号引用没有关联，则抛出错误。**那么顺序就至关重要，如果调换了目标文件的连接顺序，比如：a.o 依赖于 b.o (a.o -> b.o)，假设 b.o 在 a.o 前面，那么 b.o 中有符号定义，链接时直接放入关联成功的集合，然而在链接 a.o 时候，因为符号定义已经放入其关联成功集合，那么这里的符号引用将不会匹配到任何符号定义，抛出错误。**



**静态库**

对于有大量的目标文件，将其链接为一个可执行文件。而且其中没有被引用的也被合成为一个可执行文件，其浪费了很多空间。因此出现了**静态库**，它可以作为链接器的输入，只复制被引用的目标文件



**动态链接共享库**

静态库也有一些缺点，比如说如果多个目标文件都用到了printf函数，那么这些目标文件中都会拷贝一份printf代码，这就造成不必要的浪费。

**共享库**则是为了解决静态库的缺陷而产生。共享库在Linux以.so结尾，在windows中以称为DLL。在运行和加载时，能加载到任意的内存地址并和当前程序链接起来。

共享库是一种位置无关代码，可以加载而无需重定位。（见书P489）





# 第八章 - 异常控制流



### 异常控制流及进程

> 在程序中有分支、过程调用和返回，这些都属于程序级别的，对于系统级别发生的事，程序总要停在某处去解决系统状态变化发生的事情。比如数据从磁盘读入，ctrl+c对程序的中断，系统状态发生了变化。此时就有了**异常控制流**将其转入处理这些系统事件。

**目录**：

- 低层次
  - 异常
- 高层次（软件实现）
  - 上下文切换（os实现）
  - 信号（os实现）
  - 非本地跳转（C语言运行库实现）



异常控制流（Exceptional Control Flow，ECF），作用是使控制流发生突变，即PC发送突变，跳转到异常处理程序。

![异常剖析](D:\个人资料\Notes\csapp\img\异常剖析.png)

处理器状态被编码为不同的位和信号，状态变化称谓事件（Event），当重要事件发送时（用户模式），处理器就会通过一张**异常表**（exception table），跳转到异常处理程序（内核模式），处理后返回。

异常表其实就是一张索引为 **异常号** 的表，每个异常号标识了每种不同的异常，通过异常表基址寄存器和异常号就能在异常表中定位一项，指向异常处理程序的代码。

**异常的类别**

- 中断：**异步异常**，同时也是硬件异常，通常是定时器、 I/O等，以 I/O 为例，I/O 设备向处理器一个引脚发送信号，处理器注意到后，从系统总线读取异常号，然后将控制交给中断处理程序。
- 陷阱（trap）和系统调用（system call）：同步异常，trap是应用程序调用系统函数，用户从用户模式陷入到内核模式，执行完系统函数后返回。
- 故障：同步异常，比如缺页异常等，故障发生后控制交给故障处理程序，返回的结果可能是发生故障的PC位置，或者中止程序。
- 终止：同步异常，终止时不可恢复的，直接终止应用程序。



**进程（process）**

> 正在运行程序的实例（实际上是一种抽象）

进程抽象给了我们一种假象，每个进程“独占”的使用 cpu，独占的使用系统地址空间，这些都是抽象层面。而其实际上可由下图：

![进程抽象](D:\个人资料\Notes\csapp\img\进程抽象.png)

实际上每个程序有它独立的 stack，heap... ，每次轮到它使用 cpu 时都会将其 片段 加载进来，独占 cpu 一段时间。而后将其 寄存器值，地址空间保存起来，cpu 转换至另外的进程。此过程就叫 **上下文切换**：

上下文切换：用户模式传入内核模式，内核模式保存其寄存器的值，地址空间等等，恢复某个之前被抢占的进程，将控制转给这个进程。

![上下文切换](D:\个人资料\Notes\csapp\img\上下文切换.png)

其进程的执行可以归结为 **逻辑控制流**：

![逻辑控制流](D:\个人资料\Notes\csapp\img\逻辑控制流.png)

**Unix/Linux系统级函数**

系统级函数调用的**重要规则**:

- 必须检查系统调用的返回值，一般Linux系统函数错误返回 -1
- 有一些异常函数返回 void，例如 exit, free 

但写起来会比较冗长，可以考虑封装为一个函数，例如 error handler：

```c
if((pid = fork()) < 0) {
    fprintf(stderr, "fork error: %s\n", strerror(errno));
    exit(0);
}

// 可以将上面封装为 unix 风格的错误处理函数
void unix_error(char *msg) {
    fprintf(stderr, "%s : %s\n", msg, strerror(errno));
    exit(0);
}

//由此上面变为
if((pid = fork()) < 0)
    unix_error("fork error.");
```



获取进程ID

```c
#include <sys/types.h>
#include <unistd.h>

pid_t getpid(void);		// 获得 pid
pid_t getppid(void);	// 获得父进程 pid
```

**创建进程**

```c
#include <sys/types.h>
#include <unistd.h>

// 子进程返回 0， 父进程返回子进程 pid
pid_t fork(void);
```

fork()函数调用后，子进程copy父进程的虚拟地址空间（代码段...），同时子进程也可读写打开的文件。**子进程独立一份父进程虚拟空间的副本**



**僵尸进程**

创建出来的子进程没有通过 waitpid 函数回收，子进程终止后，处于一种**已终止**的状态，直到被父进程回收。如果父进程没有回收该子进程，那么内核安排 init 进程成为其该子进程的养父。**终止但未被回收的进程成为僵尸进程。**

回收子进程

```c
#include <sys/tpyes.h>
#include <sys/wait.h>

pid_t waitpid(pid_t pid, int *statusp, int options);
// 成功，返回子进程 PID， 如果WNOHANG，则为0，如果其它错误，则为 -1。
```

默认情况下(option = 0)，waitpid 会挂起父进程，知道它的等待集合中的**任何一个子进程终止**，并且立即返回。

```c
waitpid(-1, &status, 0) = wait(&status)
```

参数介绍：pid > 0，等待单独的子进程，进程ID为 pid。pid = -1，等待集合由父进程的所有子进程构成。详细参数见书P517



**加载并运行程序**

```c
#include <unistd.h>

int execve(const char *filename, const char *argv[], const char *envp[]);
// 成功，不返回。错误，返回 -1
```

execv 函数直接调用 filename 指定的脚本，并且会直接覆盖当前进程堆栈。其中 argv[0] == filename，argv[1...]为命令行除第一个函数名的除外的其它命令，envp为环境参数 key=value 形式。



### Linux信号

>linux 信号是一种软件形式的异常，用来允许进程和内核中断其它进程

信号本质上就是 Linux 发送给进程的一条“小消息”，其信息就只有一个信号id（1 - 30）的整数。Linux中所有的信号可以查看 P527。

kernel 发送信号有两种方式：1. 内核检测一个系统事件，比如除零错误或者子进程终止 2. 进程调用 kill 函数。

进程处理信号的方式：

- 忽略
- 终止进程
- 捕获并且调用用户级函数，即 **signal handler**

![信号捕获](D:\个人资料\Notes\csapp\img\信号捕获.png)

**进程信号的接收不是一个队列！**，这点重点，如果一个进程接收了一个信号，并且还未处理，那么该信号就为待处理信号，其它进程再次发送同种信号过来，该进程将直接丢弃。如果一个进程正在处理一种信号，那么该进程还能接收一个同种信号作为待处理信号。

**解释：**进程是利用一个 32 位的 bit vector(位向量) 来表示待处理信号，所以只有一位能被设置位待处理信号，这就是为什么信号的接收不是队列形式。

同样信号也能被阻塞，通过一个阻塞位向量来维持。



**发送信号**

首先介绍进程组的概念

**进程组**

每个进程属于一个进程组，父进程创建的子进程和父进程属于一个进程组。

```c
pid_t getpgrp(void);	// 获得进程组id
int setpgid(pid_t pid, pid_t pgid);	// 为 pid 设置进程组 pgid; 
```

进程组的概念可以让我们统一发送信号给某一进程组中的所有成员。例如 kill 命令

kill -9 1521，发送 9 号信号给 1521 进程。 kill -9 -1521，发送 9 号信号给进程组 1521 的所有进程。

**接收信号**

进程接收信号的机制：

```c
pnb = pending & ~blocked;	//通过排队中的位向量和阻塞信号的位向量非做相于，求出待处理信号为向量（排队未阻塞）
if(pnb == 0)	// 没有待处理信号，指令转回到用户进程的下一条指令
else {
    k = pnb & -pnb	// 获得第一个信号类型
    // .... 重复获得 k 的过程知道 pnb == 0，接收完所有信号
}
```

**自定义用户级信号处理函数**

```c
handler_t *signal(int signum, handler_t *handler);
// 接收 signum 信号会转到 handler 定义的过程处理函数
```

handler 形式必须是 `void (int sigint)`

信号的接收其实是一个并发的过程，信号处理函数是**内核级别**的

![信号接收](D:\个人资料\Notes\csapp\img\信号接收.png)

**阻塞信号**

```c
#include <signal.h>

int sigprocmask(int how, const sigset_t *set, sigset_t *oldset);	// 使用 set 集合且用 how 方法代替阻塞bit vecetor，原来的存入 oldset
int sigemptyset(sigset_t *set);		// 初始化 empty set
int sigfillset(sigset_t *set);		// 填充
int sigaddset(sigset_t *set, int signum);		// 使用 signum 对应的信号 添加到 set 中
// 成功，返回 0，否则返回 -1
int sigismemeber(const sigset_t, int signum);	// 如果 signum 是 set 中的成员（已经被设置），返回 1，否则返回 0，出错返回 -1

```

