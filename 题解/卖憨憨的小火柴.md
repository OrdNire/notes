# 卖憨憨的小火柴

### 

#### Description

> 冬天到了，小火柴又带着憨憨去大街上找买家，但是憨憨厌倦了这样的日子，于是他选择了反抗，小火柴想和平地解决，他知道憨憨的数学不好，于是出了一道题，题目给了你三角形的一条边的长度x1以及n个整数x，憨憨需要选择x中的两个数字作为另外两条边长度x2,x3，现在憨憨需要摆出能够构成的所有的三角形，然后告诉小火柴摆出的三角形的数量，如果最后答案正确了，那么憨憨就可以重获自由了，否则他就只能乖乖被卖了，所以憨憨请你来帮助他重获自由，请你告诉憨憨最后的答案。



#### input

> 第一行输入两个整数n,x1(1 <= n <= 1e5,1 <= x1 <= 1e9)
>
> 第二行输入n个整数x(1 <= x <= 1e9)



#### output

输入一个整数，表示答案



#### Sample input

```
4 1
1 1 2 3
```

#### Sample Output

```
1
```

#### Hint

```
我们取x2 = 1,x3 = 1，然后x1 = 1，这个时候可以构成三角形，仅有这种情况能够构成。
```





**题解**

本题题目只给出了三角形的一条边，那么此时需要确定另外两条边是否能够构成三角形，我们可以循环 确定一条边，另外一条二分确定，如果我们确定出了两条边，另外一条边一定要比这两条之和小以及要 比两数之差大，那么我们就确定出第一个大于两数之差的索引x 和第一个大于等于两数之和的索引 y，那 么最终的可以形成三角形的边的区间就是 [x,y)个数就是 (y - 1) - x + 1，我们可以用upper_bound和 lower_bound实现。



**代码**

```c
#include <bits/stdc++.h>
using namespace std;

typedef long long ll;
const int N = 100010;
int a[N];
int n,p,x;
ll ans;

int main()
{
	scanf("%d %d",&n,&p);
	
	for(int i = 0;i < n;i ++) scanf("%d",&a[i]);
	
	sort(a,a + n);
	
	for(int i = 0;i < n - 1;i ++){
		int x = lower_bound(a + i + 1,a + n,a[i] + p) - a;
		int y = upper_bound(a + i + 1,a + n,p - a[i]) - a;
		ans += 1ll * max(0,x - y);
	}
	printf("%lld",ans);
	return 0;
}
```

