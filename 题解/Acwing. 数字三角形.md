# Acwing. 数字三角形

给定一个如下图所示的数字三角形，从顶部出发，在每一结点可以选择移动至其左下方的结点或移动至其右下方的结点，一直走到底层，要求找出一条路径，使路径上的数字的和最大。

```
        7
      3   8
    8   1   0
  2   7   4   4
4   5   2   6   5
```

#### 输入格式

第一行包含整数n，表示数字三角形的层数。

接下来n行，每行包含若干整数，其中第 i 行表示数字三角形第 i 层包含的整数。

#### 输出格式

输出一个整数，表示最大的路径数字和。

#### 数据范围

1≤*n*≤500,
−10000≤三角形中的整数≤10000

#### 输入样例：

```
5
7
3 8
8 1 0 
2 7 4 4
4 5 2 6 5
```

#### 输出样例：

```
30
```



**题解**

可以从下到上分析

**分为两种情况**：

- 从左下方上来的一种情况
- 从右下方上来的一种情况
- 取这两种情况的最大值

而从下方来的情况也是上述分析而来，也就是说，下方来的情况也是按照上述方法得到的最大值



**代码**

```c
#include <iostream>
using namespace std;

const int N = 510;
int w[N][N],f[N][N];
int n;


int main()
{
    cin >> n;
    for(int i = 1;i <= n;i ++)
        for(int j = 1;j <= i;j ++) cin >> w[i][j];
        
    for(int i = 1;i <= n;i ++) f[n][i] = w[n][i];
    
    for(int i = n - 1;i >= 0;i --)
        for(int j = 1;j <= i;j ++)
            f[i][j] = max(f[i + 1][j] + w[i][j], f[i + 1][j + 1] + w[i][j]);
    
    cout << f[1][1];
    return 0;
}
```

