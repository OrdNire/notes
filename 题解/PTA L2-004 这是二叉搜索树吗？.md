原题链接：[这是二叉搜索树吗](https://pintia.cn/problem-sets/994805046380707840/problems/994805070971912192)

### 题目描述

一棵二叉搜索树可被递归地定义为具有下列性质的二叉树：对于任一结点，

1. 其左子树中所有结点的键值小于该结点的键值；
2. 其右子树中所有结点的键值大于等于该结点的键值；
3. 其左右子树都是二叉搜索树。

所谓二叉搜索树的“镜像”，即将所有结点的左右子树对换位置后所得到的树。

给定一个整数键值序列，现请你编写程序，判断这是否是对一棵二叉搜索树或其镜像进行前序遍历的结果。

##### 输入格式

输入的第一行给出正整数 $N（≤1000）$。随后一行给出 $N$ 个整数键值，其间以空格分隔。

##### 输出格式

如果输入序列是对一棵二叉搜索树或其镜像进行前序遍历的结果，则首先在一行中输出 `YES` ，然后在下一行输出该树后序遍历的结果。数字间有 1 个空格，一行的首尾不得有多余空格。若答案是否，则输出 `NO`。


##### 输入样例1：

```
7
8 6 5 7 10 8 11
```

##### 输出样例1：

```
YES
5 7 6 8 11 10 8
```
##### 输入样例2：

```
7
8 10 11 8 6 7 5
```

##### 输出样例2：

```
YES
11 8 10 7 5 6 8
```

##### 输入样例3：

```
7
8 6 8 5 10 9 11
```

##### 输出样例3：

```
NO
```

### 思路



如果是一个严格的二叉搜索树，那么如果根据前序遍历来建树，每一次可以以前序遍历的第一个值为根，根后面可以分为连续的小于根的部分和大于等于根的部分，**且分界线相差1（相邻）**

而如果前序遍历的结果不是又二叉搜索树来的，那么必然分界线相差大于1

考虑第三个样例：

```
8 6 8 5 10 9 11

8 为根， 6 为其左子树部分; 10 9 11 为其右子树部分
而 6 和 10 的位置相差为 3，此时不是二叉搜索树
```



**如果直接根据输入的前序遍历来建树，因为分界线相差大于1，那么建立的数的节点数必然小于 n ，由此可判断是否是二叉搜索树**

考虑镜像，如果正序不是二叉搜索树，那么可以镜像来一遍，如果还不是则答案是否



#### C++ 代码
```cpp
#include <iostream>
#include <vector>
using namespace std;

const int N = 1010;
int p[N];
vector<int> res;
bool ismirror;
int n;

void create(int l,int r) {
	if(l > r) return;
	
	//l + 1 ~ tl
	int tr = l + 1;
	// tr ~ r;
	int tl = r;
	
	if(!ismirror) {
		while(tr <= r && p[tr] < p[l]) tr ++;
		while(tl > l && p[tl] >= p[l]) tl --;
	}else {
		while(tr <= r && p[tr] >= p[l]) tr ++;
		while(tl > l && p[tl] < p[l]) tl --;
	}
	
	create(l + 1, tl);
	create(tr,r);
	
	res.push_back(p[l]);
}

int main()
{
	cin >> n;
	
	for(int i = 0;i < n;i ++) cin >> p[i];
	
	create(0,n - 1);
	
	if(res.size() != n) ismirror = true;
	
	res.clear();
	create(0,n - 1);
	
	if(res.size() != n) printf("NO\n");
	else {
		printf("YES\n");
		for(int i = 0;i < res.size();i ++)
			if(i) printf(" %d",res[i]);
			else printf("%d",res[i]);
	}
	return 0;
}
```

----------

