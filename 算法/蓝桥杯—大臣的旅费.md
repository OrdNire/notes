原题链接：[大臣的旅费](https://www.acwing.com/problem/content/1209/)

### 题目描述

很久以前，T王国空前繁荣。

为了更好地管理国家，王国修建了大量的快速路，用于连接首都和王国内的各大城市。

为节省经费，T国的大臣们经过思考，制定了一套优秀的修建方案，使得任何一个大城市都能从首都直接或者通过其他大城市间接到达。

同时，如果不重复经过大城市，从首都到达每个大城市的方案都是唯一的。

J是T国重要大臣，他巡查于各大城市之间，体察民情。

所以，从一个城市马不停蹄地到另一个城市成了J最常做的事情。

他有一个钱袋，用于存放往来城市间的路费。

聪明的J发现，如果不在某个城市停下来修整，在连续行进过程中，他所花的路费与他已走过的距离有关，在走第x千米到第x+1千米这一千米中（x是整数），他花费的路费是x+10这么多。也就是说走1千米花费11，走2千米要花费23。

J大臣想知道：他从某一个城市出发，中间不休息，到达另一个城市，所有可能花费的路费中最多是多少呢？

##### 输入格式

输入的第一行包含一个整数 $n$，表示包括首都在内的T王国的城市数。

城市从 $1$ 开始依次编号，$1$ 号城市为首都。

接下来 $n−1$ 行，描述T国的高速路（T国的高速路一定是 $n−1$ 条）。

每行三个整数 $P_i,Q_i,D_i，$表示城市 $P_i$ 和城市 $Q_i$ 之间有一条双向高速路，长度为 $D_i$ 千米。

##### 输出格式

输出一个整数，表示大臣J最多花费的路费是多少。 

#### 数据范围

$1≤n≤105,$
$1≤Pi,Qi≤n,$
$1≤Di≤1000$

##### 输入样例1：

```
5 
1  2  2 
1  3  1 
2  4  5 
2  5  4 
```

##### 输出样例1：

```
135
```

### 思路

本道题因为边数是 $n - 1$ ，且题目给出 `如果不重复经过大城市，从首都到达每个大城市的方案都是唯一的。` ，那么这是一个无环图，也就是树，本题求某一个点出发到另一个点路费最多，那么就转换为了求树/图的直径问题

**树/图直径的求法**

- 任取一个点，找到离该点最远的那一个点，计为$K$
- 再用上述方法，找到离 $K$ 点最远的点，计为 $L$

那么$K- L$ 即为树/图的直径，上述算法的**本质就是求出直径的两个端点**

证明（反证法）：

假设$C-D$ 是直径，$B$ 是根据 $A$ 点求出来的直径的离 $A$ 点最远的点

![大臣的旅费](D:\个人资料\Notes\算法\images\大臣的旅费.png)

先看图1：

因为 $AHB > AHD$，所以 $HB > HD$ ，所以 $CHB > CHD$，因为 $C-D$ 是直径， $CHD > CHB$ ，矛盾，所以  $C-D$ 不是直径

图2：

因为 $AB > AEFD$，所以 $EB > EFD$，$FEB > FD$，$CFEB > CD$，因为 $C-D$ 是直径，$CD > CFEB$ ，矛盾，所以 $C-D$ 不是直径

所以，这道题我们只需要两边dfs求出最远距离即可



可以采用数组模拟邻接表或者vector模拟

#### 时间复杂度

$O(n)$

#### C++ 代码
```cpp
#include <iostream>
#include <cstring>
#include <vector>
using namespace std;

const int N = 100010;
struct Edge {
    int id, w;
};
vector<Edge> h[N];
int dis[N];
int n;

void dfs(int u,int father,int distance) {
    
    dis[u] = distance;
    
    for(auto t : h[u])
        if(t.id != father)
            dfs(t.id, u, distance + t.w);
}

int main()
{
    cin >> n;
    for(int i = 1;i < n;i ++) {
        int a, b, c;
        scanf("%d%d%d",&a,&b,&c);
        h[a].push_back({b,c});
        h[b].push_back({a,c});
    }
    
    dfs(1, -1, 0);
    
    int u = 1;
    for(int i = 1;i <= n;i ++)
        if(dis[i] > dis[u])
            u = i;
    
    dfs(u, -1, 0);
    
    for(int i = 1;i <= n;i ++)
        if(dis[i] > dis[u])
            u = i;
    
    int s = dis[u];
    printf("%lld\n",s * 10 + s * (s + 1ll) / 2);
    return 0;
}
```

----------



