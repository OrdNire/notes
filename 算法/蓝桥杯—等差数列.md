原题链接：[等差数列](https://www.acwing.com/problem/content/description/1248/)

### 题目描述

数学老师给小明出了一道等差数列求和的题目。

但是粗心的小明忘记了一部分的数列，只记得其中 $N$ 个整数。

现在给出这 $N$ 个整数，小明想知道包含这 $N$ 个整数的最短的等差数列有几项？

##### 输入格式

输入的第一行包含一个整数 $N。$

第二行包含 $N$ 个整数 $A_1,A_2,⋅⋅⋅,A_N。$(注意 $A_1∼A_N$ 并不一定是按等差数列中的顺序给出)

##### 输出格式

输出一个整数表示答案。

#### 数据范围

$2≤N≤100000,$
$0≤Ai≤109$

##### 输入样例1：

```
5
2 6 4 10 20
```

##### 输出样例1：

```
10
```

##### 样例解释

包含 $2、6、4、10、20$ 的最短的等差数列是 $2、4、6、8、10、12、14、16、18、20$


### 思路

等差数列项数的公式为	$ (a_n - a_1) / d + 1$，其中 $a_n$ 为等差数列的末项，在序列中就是最大值，$a_1$ 为等差数列的首项，在序列中就是最小值

所以要求序列最短，因为最大值和最小值已经固定，要求的就是公差 $d$ 的最大值

因为等差序列可以表示为 $a_1,a_1 + d,a_1 + 2d,a_1 + 3d,....,a_1 + nd$ ，可以观察到等差数列的每一项和第一项的差值都是 $d$ 的倍数，所以求 $d$ 的最大值就是求序列给出的项数差值的最大公约数

#### 时间复杂度

$O(nlogn)$

#### C++ 代码
```cpp
#include <iostream>
#include <algorithm>
using namespace std;

const int N = 100010;
int a[N];
int n;

int gcd(int a,int b) {
    return b ? gcd(b, a % b) : a;
}

int main()
{
    scanf("%d",&n);
    for(int i = 0;i < n;i ++) scanf("%d",&a[i]);
    sort(a,a + n);
    
    int d = 0;
    for(int i = 1;i < n;i ++) d = gcd(d, a[i] - a[i - 1]);
    
    if(!d) printf("%d\n",n);
    else printf("%d\n",(a[n - 1] - a[0]) / d + 1);
    
    return 0;
}
```

----------