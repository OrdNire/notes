# 并查集

**背景**

解密犯罪团伙，警方根据证据，搜集到了一些犯罪人之间的关系。要求找出有多少个犯罪团伙

```
输入:
第一行n m，n表示强盗人数，m表示搜集到证据的条数
接下来m行有a,b，表明a和b是同伙
```

该方法可以用并查集解出有多少个犯罪团伙



**并查集算法**

并查集本质上是维护一个森林，森林中的每个点都是孤立的，可以说每个点都是只有一个节点的树



**过程**

我们可以利用树来表示关系，某个节点的父节点就是它直属上司，某节点的祖宗在该题中可以视为犯罪团伙的boss

**我们用一个一维数组来存储每个节点的祖宗**

**初始化**

初始化一维数组，以下标作为节点的编号，初始化值为本身，即一开始的boss就是自己本身

**"靠左"法则**

根据a,b同伙关系，可以将b归谁于a，即将b作为a节点祖宗的一个孩子。遍历每条证据的时候，找出a，b的祖先，将b的祖先作为a的孩子，即将b所在的树加入到a所在的树中

**"路径压缩"**

在我们找祖宗的时候，可以根据递归的回溯，将祖宗的每个二级孩子的直属上司都改为该祖宗，即让每个节点直接成为祖宗的孩子。**这样可以减少下次找祖宗所用的时间和空间，这个方法在并查集中称为"路径压缩"**



处理完后如果结点的直属上司就是它自己，那么它就是一棵树的祖宗，统计个数，即为有多少个犯罪团伙，问题解决



**代码**

```c
#include <stdio.h>

//	并查集
//	要求：根据犯罪的同伙关系，统计有多少个犯罪团队 

int f[10001],n,m,sum = 0;
void init(){
	for(int i=1;i<=n;i++){
		f[i] = i;
	}
	return;
}

int getFather(int v){
	if(f[v] == v){
		return v;
	}else{
		f[v] = getFather(f[v]);		//递归回溯，将根节点设置为路上经过的所有结点的父亲 
		return f[v];				//并查集的"路径压缩" 
	}
}

void merge(int v,int u){
	int t1,t2;		//记录v,u的祖先
	t1 = getFather(v);
	t2 = getFather(u);
	if(t1 != t2){
		f[t2] = t1;		// 根据"靠左原则"将右边的集合作为左边的集合的子集 
	} 
}



int main()
{
	
	int x,y;
	scanf("%d %d",&n,&m);
	init();		//初始化 
	for(int i=0;i<m;i++){
		scanf("%d %d",&x,&y);
		merge(x,y);
	}
	
	for(int i=1;i<=n;i++){
		if(f[i] == i){
			sum++;
		}
	}
	
	printf("sum=%d",sum);
	
	return 0;
}
```



