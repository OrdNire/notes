原题链接：[乘积最大](https://www.acwing.com/problem/content/1241/)

### 题目描述

给定 $N$ 个整数 $A_1,A_2,…A_N。$

请你从中选出 $K$ 个数，使其乘积最大。 

请你求出最大的乘积，由于乘积可能超出整型范围，你只需输出乘积除以 1000000009 的余数。 

注意，如果 $X<0$， 我们定义 $X$ 除以 1000000009 的余数是负$(−X)$除以 1000000009 的余数，即：0−((0− $x $)%1000000009)

##### 输入格式

第一行包含两个整数 $N$ 和 $K。$

以下 $N$ 行每行一个整数 $A_i。$

##### 输出格式

输出一个整数，表示答案。

#### 数据范围

$1≤K≤N≤105,$
$−105≤Ai≤105$

##### 输入样例1：

```
5 3
-100000
-10000
2
100000
10000
```

##### 输出样例1：

```
999100009
```

##### 输入样例2：

```
5 3
-100000
-100000
-2
-100000
-100000
```

##### 输出样例2：

```
-999999829
```



### 思路

我们要求的是乘积的值最大

可以先对序列排序，因为序列中有正有负，那么排序后的序列最左边就是最小的负数（如果有负数），也就是绝对值最大的负数，最右边是最大的正数（如果有正数）

考虑到 $k$ 存在奇偶，所以我们需要分情况讨论

$k == n$ ：那么答案就是所有值的乘积

$k < n且k 为偶数$：乘积最大值必定为正数

- 如果序列中负数的个数为偶数，那么总能找到成对的负数，使得其答案为正数
- 如果序列中负数的个数为奇数，那么我们可以只选择偶数个绝对值最大的负数

$k < n且k为奇数$

- 如果序列中全为负数，那么结果必为负数，为了使得答案最大，我们需要选绝对值最小的数
- 如果序列中至少存在一个正数，那么我们可以先选择最大的那个正数，$k$ 减少一个，转换为了 $k$ 为偶数的情况



因为如果$k$为奇数，可以通过先选一个特判来转换为 $k$ 为偶数的做法，所以可以同一对 $k$ 为偶数进行操作

那么经过分析，可以采用双指针的算法，两个为一对的移动指针来计算每一对的值，因为序列最左边如果有负数就是绝对值最大的负数，序列最右边如果有正数就是绝对值最大的正数，所以两个指针分别头和尾来一对一对移动，判断哪一对的值最大

#### 时间复杂度

$O(nlogn)$

#### C++ 代码
```cpp
#include <iostream>
#include <cstdio>
#include <algorithm>
#include <cstring>
using namespace std;

typedef long long LL;

const int N = 100010, mod = 1000000009;
int a[N];
int n, k;

int main()
{
    scanf("%d%d",&n,&k);
    
    for(int i = 0;i < n;i ++) scanf("%d",&a[i]);
    sort(a, a + n);
    
    int res = 1;
    int l = 0, r = n - 1;
    int sign = 1;
    if(k & 1) {
        res = a[r --];
        if(res < 0) sign = -1;
        k --;
    }
    while(k) {
        LL x = (LL)a[l] * a[l + 1], y = (LL)a[r - 1] * a[r];
        if(x * sign > y * sign) {
            res = x % mod * res % mod;
            l += 2;
        }else {
            res = y % mod * res % mod;
            r -= 2;
        }
        k -= 2;
    }
    
    printf("%d\n",res);
    return 0;
}
```

----------


