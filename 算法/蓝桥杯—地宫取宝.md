原题链接：[acwing.地宫取宝](https://www.acwing.com/problem/content/1214/)

### 题目描述

$X$ 国王有一个地宫宝库，是 $n×m$

个格子的矩阵，每个格子放一件宝贝，每个宝贝贴着价值标签。

地宫的入口在左上角，出口在右下角。

小明被带到地宫的入口，国王要求他只能向右或向下行走。

走过某个格子时，如果那个格子中的宝贝价值比小明手中任意宝贝价值都大，小明就可以拿起它（当然，也可以不拿）。

当小明走到出口时，如果他手中的宝贝恰好是 $k$ 件，则这些宝贝就可以送给小明。

请你帮小明算一算，在给定的局面下，他有多少种不同的行动方案能获得这 $k$ 件宝贝。

##### 输入格式

第一行 $3$ 个整数，$n,m,k$，含义见题目描述。

接下来 $n$ 行，每行有 $m$ 个整数 $C_i$ 用来描述宝库矩阵每个格子的宝贝价值。

##### 输出格式

输出一个整数，表示正好取 $k$ 个宝贝的行动方案数。

该数字可能很大，输出它对 $1000000007$ 取模的结果。

#### 数据范围

$1≤n,m≤50,$
$1≤k≤12,$
$0≤Ci≤12$

##### 输入样例1：

```
2 2 2
1 2
2 1
```

##### 输出样例1：

```
2
```

##### 输入样例2：

```
2 3 2
1 2 3
2 1 5
```

##### 输出样例2：

```
14
```





### DP

`状态表示`：`f[i][j][k][c]` 表示从起点走到 $(i,j)$ ，拿了 $k$ 件物品且手上最大的价值为 $c$ 

**状态转移分析 **：

可以分为一下几个状态

**从上侧来**：

- 不取
  - `f[i][j][k][c] += f[i - 1][j][k][c]`

- 取

  **如果要取当前的宝藏，需要满足当前状态的 `c == 当前位置的宝藏价值` 因为如果取完当前宝藏后，必须满足最大的价值为 $c$ **

  然后我们只需要每次都加上比 $c$ 小的部分的方案数即可

  `f[i][j][k][c] += f[i - 1][j][k - 1][小于c的数]`



**初始化**：

对于 $(1,1)$ 点，即起点，我们也有取和不取两种状态

- 对于取，我们只需要初始化`f[1][1][1][w[i][j]] = 1` 即可，即走到 $(1,1)$ 有一个宝藏且手上最大价值为 $w_i,_j$ 的方案数
- 同理对于不取，我们需要初始化 `f[1][1][0][比给定的C还要小]` 即可，因为要比 $0≤Ci≤12$ 还要小，所以我们可以将 $C_i$ 整体 + 1



#### 时间复杂度

$O(n^5)$

#### C++ 代码
```cpp
#include <iostream>
#include <cstring>
using namespace std;

const int N = 55, mod = 1000000007;

int w[N][N];
int f[N][N][13][14];
int n, m, k;

int main()
{
    cin >> n >> m >> k;
    
    for(int i = 1;i <= n;i ++)
        for(int j = 1;j <= m;j ++) {
            cin >> w[i][j];
            w[i][j] ++;	// 因为初始化要0表示比给定范围c还小，所以整体偏移一位
        }
        
    f[1][1][1][w[1][1]] = 1;
    f[1][1][0][0] = 1;
    
    for(int i = 1;i <= n;i ++)
        for(int j = 1;j <= m;j ++) {
            if(i == 1 && j == 1) continue;
            
            for(int u = 0;u <= k;u ++)
                for(int v = 0;v <= 13;v ++) {
                    int &val = f[i][j][u][v];
                    val = (val + f[i - 1][j][u][v]) % mod;
                    val = (val + f[i][j - 1][u][v]) % mod;
                    if(w[i][j] == v) {
                        for(int c = 0;c < v;c ++) {
                            val = (val + f[i - 1][j][u - 1][c]) % mod;
                            val = (val + f[i][j - 1][u - 1][c]) % mod;
                        }
                    }
                }
        }
        
    int res = 0;
    for(int i = 0;i <= 13;i ++) res = (res + f[n][m][k][i]) % mod;
    
    cout << res << endl;
    
    return 0;
}
```

----------



