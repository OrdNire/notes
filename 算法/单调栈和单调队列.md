# 单调栈和单调队列

单调栈是一组序列单调的栈

> 例子：给定一个长度为N的整数数列，输出每个数左边第一个比它小的数，如果不存在则输出-1。
>
> #### 输入格式
>
> 第一行包含整数N，表示数列长度。
>
> 第二行包含N个整数，表示整数数列。
>
> #### 输出格式
>
> 共一行，包含N个整数，其中第i个数表示第i个数的左边第一个比它小的数，如果不存在则输出-1。
>
> #### 数据范围
>
> 1≤*N*≤105
>
> 1≤数列中元素≤109
> 
>
> 
>#### 输入样例：
> 
>```
> 5
> 3 4 2 7 5
> ```
> 
>#### 输出样例：
> 
>```
> -1 3 -1 2 2
> ```



**分析**

使用朴素做法，双层循环找到当前点左边离它最近的数，时间复杂度为O(n)



设想，设i在j的左边，那么如果数组中Xi大于等于Xj，即左边的数大于等于右边的数，在求某个数左边离他最近的比他小的数，那么Xi这个数一定不会被用到，可以删除



所以可以用栈来保持一个单调的序列，拿当前节点与栈中的元素相比，如果小于等于栈顶元素，栈顶出栈，直到栈顶元素小于当前元素。那么输出时，只需输出栈顶元素即为左边离它最近的最小的数



**代码**

```c
#include <iostream>
using namespace std;

const int N = 100010;
int stk[N],tt;

int main()
{
    int m,x;
    cin >> m;
    while(m --){
        cin >> x;
        while(tt && stk[tt] >= x) tt --;
        if(tt) cout << stk[tt] << " ";
        else cout << -1 << " ";
        stk[++ tt] = x;
    }
    return 0;
}
```



**单调队列**

单调队列的典型应用就是滑动窗口

> 给定一个大小为*n*≤106
>
> 的数组。 
>
> 有一个大小为k的滑动窗口，它从数组的最左边移动到最右边。 
>
> 您只能在窗口中看到k个数字。 
>
> 每次滑动窗口向右移动一个位置。 
>
> 以下是一个例子：
>
> 该数组为[1 3 -1 -3 5 3 6 7]，k为3。
>
> | 窗口位置                  | 最小值 | 最大值 |
> | ------------------------- | ------ | ------ |
> | [1  3  -1] -3  5  3  6  7 | -1     | 3      |
> | 1 [3  -1  -3] 5  3  6  7  | -3     | 3      |
> | 1  3 [-1  -3  5] 3  6  7  | -3     | 5      |
> | 1  3  -1 [-3  5  3] 6  7  | -3     | 5      |
> | 1  3  -1  -3 [5  3  6] 7  | 3      | 6      |
> | 1  3  -1  -3  5 [3  6  7] | 3      | 7      |
>
> 您的任务是确定滑动窗口位于每个位置时，窗口中的最大值和最小值。
>
> #### 输入格式
>
> 输入包含两行。 
>
> 第一行包含两个整数n和k，分别代表数组长度和滑动窗口的长度。 
>
> 第二行有n个整数，代表数组的具体数值。
>
> 同行数据之间用空格隔开。
>
> #### 输出格式
>
> 输出包含两个。
>
> 第一行输出，从左至右，每个位置滑动窗口中的最小值。
>
> 第二行输出，从左至右，每个位置滑动窗口中的最大值。
>
> #### 输入样例：
>
> ```
> 8 3
> 1 3 -1 -3 5 3 6 7
> ```
>
> #### 输出样例：
>
> ```
> -1 -3 -3 -3 3 3
> 3 3 5 5 6 7
> ```



**分析**

如果根据朴素做法，双层循环，找到每一个窗口中的最大值最小值，时间复杂度为O(n)

优化操作：维护单调队列

假设区间内左边的数大于右边的数，那么左边的数因为是在左边，会比右边的数更早的出窗口，而且比右边的数大，那么该数必不是最小值且永远不会用到它，所以它可以删除。用队列维护就是如果滑动窗口右边进来一个数，该数比队尾的数小，则出队尾，直到大于队尾的数，那么该队列中对头为窗口中最小的值

如果队列中对头的下标超出滑动窗口，对头出队



**代码**

```c
#include <iostream>
using namespace std;

const int N = 1000010;

int a[N],q[N];
int n,k;


int main()
{
    scanf("%d%d",&n,&k);
    
    for(int i = 0;i < n;i ++) scanf("%d",&a[i]);
    
    int hh = 0,tt = -1;
    for(int i = 0;i < n;i ++){
        
        if(hh <= tt && q[hh] < i - k + 1) hh ++;
        while(hh <= tt && a[q[tt]] >= a[i]) tt --;
        q[ ++ tt] = i;
        if(i >= k - 1) printf("%d ",a[q[hh]]);
    }
    puts("");
    hh = 0,tt = -1;
    for(int i = 0;i < n;i ++){
        
        if(hh <= tt && q[hh] < i - k + 1) hh ++;
        while(hh <= tt && a[q[tt]] <= a[i]) tt --;
        q[ ++ tt] = i;
        if(i >= k - 1) printf("%d ",a[q[hh]]);
    }
    puts("");
    return 0;
}
```

